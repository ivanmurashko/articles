%% -*- coding:utf-8 -*- 
\documentclass[14pt,a4paper]{article} 

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{minted}
\usepackage{longtable}

\title{C++ ABI}
\author{Мурашко И. В.}
\date{}
\begin{document}

\Russian

\maketitle

\section*{Введение}
По роду своей деятельности мы часто сталкиваемся с библиотеками сторонних 
разработчиков которые предоставляются нам в бинарной форме, например 
Oracle OCCI. Вместе с тем в разработке мы используем разные версии 
компиляторов gcc, которые не всегда совместимы по умолчанию с Oracle OCCI. 
В данном докладе детально описываются соответствующие проблемы и способы 
их решения. 

\section{API vs ABI}

TBD

\section{gcc5 ABI}

Версия 5 компилятора gcc была одной из первых, которая полностью (?)
поддерживала новый стандарт c++11. Новые конструкции этого стандарта
требовали изменений в двоичном представлении некоторых объектов STL.

Рассмотрим следующий фрагмент
\inputminted{c++}{./src/sizes.cpp}

Запущенный под разными версиями компилятора gcc он дает следующие
результаты 
\begin{longtable}{|l|c|c|}
\hline
Контейнер STL & gcc 4.9.4 & gcc 5.5.0 \\
\hline
std::vector & 24 & 24 \\
std::queue & 80 & 80 \\
std::priority\_queue & 32 & 32 \\
std::deque & 80 & 80 \\
std::stack & 80 & 80 \\
std::set & 48 & 48 \\
std::multiset & 48 & 48 \\
std::map & 48 & 48 \\
std::multimap & 48 & 48 \\
std::list & 16 & 24 \\
std::string & 8 & 32 \\
\hline
\end{longtable}

Как видно двоичное представление как минимум двух контейнеров
(std::list и std::string) различается между двумя этими версиями
компиляторов.

Связано это прежде всего с тем, что libstdc++ GCC 5.1 ввела
\cite{DualABI}  новую имплементацию данных контейнеров. Если
посмотреть на размер std::list в gcc 4 то видно что размер равен
удвоенному размеру
указателя (16 bytes), что соответствует представлению std::list как
двусвязанного списка: каждый элемент содержит указатели на предыдущий
и следующий элементы. Такой способ хранения не соответствует стандарту
C++ 2011, который явно требует чтобы вычисление размера контейнеров, и
в частности списка имело бы сложность $O(1)$ \cite{cpp11}, что требует хранения
дополнительных данных вместе с указателем на последующий элемент.  



%% прежде всего это касается std::list, std::string, std::ios\_base,
%% std::locale. 

%% Dual ABI
%% In the GCC 5.1 release libstdc++ introduced a new library ABI that
%% includes new implementations of std::string and std::list. These
%% changes were necessary to conform to the 2011 C++ standard which
%% forbids Copy-On-Write strings and requires lists to keep track of
%% their size. 

%% In order to maintain backwards compatibility for existing code linked
%% to libstdc++ the library's soname has not changed and the old
%% implementations are still supported in parallel with the new ones.
%% This is achieved by defining the new implementations in an inline
%% namespace so they have different names for linkage purposes, e.g. the
%% new version of std::list<int> is actually defined as
%% std::__cxx11::list<int>. Because the symbols for the new
%% implementations have different names the definitions for both versions
%% can be present in the same library. 

%% The \_GLIBCXX\_USE\_CXX11\_ABI macro (see Macros) controls whether the
%% declarations in the library headers use the old or new ABI. So the
%% decision of which ABI to use can be made separately for each source
%% file being compiled. Using the default configuration options for GCC
%% the default value of the macro is 1 which causes the new ABI to be
%% active, so to use the old ABI you must explicitly define the macro to
%% 0 before including any library headers. (Be aware that some GNU/Linux
%% distributions configure GCC 5 differently so that the default value of
%% the macro is 0 and users must define it to 1 to enable the new ABI.) 

%% Although the changes were made for C++11 conformance, the choice of
%% ABI to use is independent of the -std option used to compile your
%% code, i.e. for a given GCC build the default value of the
%% \_GLIBCXX\_USE\_CXX11\_ABI macro is the same for all dialects. This
%% ensures that the -std does not change the ABI, so that it is
%% straightforward to link C++03 and C++11 code together.

%% Because std::string is used extensively throughout the library a
%% number of other types are also defined twice, including the
%% stringstream classes and several facets used by std::locale. The
%% standard facets which are always installed in a locale may be present
%% twice, with both ABIs, to ensure that code like
%% std::use\_facet<std::time_get<char>>(locale); will work correctly for
%% both std::time\_get and std::\_\_cxx11::time\_get (even if a user-defined
%% facet that derives from one or other version of time\_get is installed
%% in the locale). 

%% Although the standard exception types defined in <stdexcept> use
%% strings, they are not defined twice, so that a std::out\_of\_range
%% exception thrown in one file can always be caught by a suitable
%% handler in another file, even if the two files are compiled with
%% different ABIs. 



\subsection{std::string}

Рассмотрим следующий фрагмент
\inputminted{c++}{./src/str.cpp}

GCC 5 дает вполне предсказуемый вывод: мы получаем копию строки со
своими внутренними данными
\begin{minted}{shell}
$ ./str5
0x7ffc757fc1b0
0x7ffc757fc200
$
\end{minted}

Другая ситуация GCC 4:
\begin{minted}{shell}
$ ./str4
0x1d5be88
0x1d5be88
$
\end{minted}


TBD

\subsection{std::list}

TBD

\subsection{std::ios\_base}

TBD

\section{Бинарные внешние библиотеки}

TBD

\bibliographystyle{gost780s}  %% стилевой файл для оформления по
\bibliography{cppabi}     %% имя библиографической базы (bib-файла)


\end{document}
