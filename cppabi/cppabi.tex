%% -*- coding:utf-8 -*- 
\documentclass[14pt,a4paper]{article} 

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{minted}
\usepackage{longtable}

\title{C++ ABI}
\author{Мурашко И. В.}
\date{}
\begin{document}

\Russian

\maketitle

\section*{Введение}
По роду своей деятельности мы часто сталкиваемся с библиотеками сторонних 
разработчиков которые предоставляются нам в бинарной форме, например 
Oracle OCCI. Вместе с тем в разработке мы используем разные версии 
компиляторов gcc, которые не всегда совместимы по умолчанию с Oracle OCCI. 
В данном докладе детально описываются соответствующие проблемы и способы 
их решения. 

\section{API vs ABI}

Когда кто-то собирается использовать внешнюю библиотеку, то первое что
интересует - какой интерфейс она предоставляет. Этот интрефейс мы
называем API (Application Program Interface). Месте с тем кроме этого
интерфейса иногда большое 
значение имеет двоично представление данных библиотеки, которое
называется ABI (Application binary interface).
TBD

\section{gcc5 ABI}

Версия 5 компилятора gcc была одной из первых, которая полностью (?)
поддерживала новый стандарт c++11. Новые конструкции этого стандарта
требовали изменений в двоичном представлении некоторых объектов STL.

Рассмотрим следующий фрагмент
\inputminted{c++}{./src/sizes.cpp}

Запущенный под разными версиями компилятора gcc он дает следующие
результаты 
\begin{longtable}{|l|c|c|}
\hline
Контейнер STL & gcc 4.9.4 & gcc 5.5.0 \\
\hline
std::vector & 24 & 24 \\
std::queue & 80 & 80 \\
std::priority\_queue & 32 & 32 \\
std::deque & 80 & 80 \\
std::stack & 80 & 80 \\
std::set & 48 & 48 \\
std::multiset & 48 & 48 \\
std::map & 48 & 48 \\
std::multimap & 48 & 48 \\
std::list & 16 & 24 \\
std::string & 8 & 32 \\
\hline
\end{longtable}

Как видно двоичное представление как минимум двух контейнеров
(std::list и std::string) различается между двумя этими версиями
компиляторов.

Связано это прежде всего с тем, что libstdc++ GCC 5.1 ввела
\cite{DualABI}  новую имплементацию данных контейнеров. Если
посмотреть на размер std::list в gcc 4 то видно что размер равен
удвоенному размеру
указателя (16 bytes), что соответствует представлению std::list как
двусвязанного списка: каждый элемент содержит указатели на предыдущий
и следующий элементы. Такой способ хранения не соответствует стандарту
C++ 2011, который явно требует чтобы вычисление размера контейнеров, и
в частности списка имело бы сложность $O(1)$ \cite{cpp11}, что требует хранения
дополнительных данных вместе с указателем на последующий элемент.  



%% прежде всего это касается std::list, std::string, std::ios\_base,
%% std::locale. 

%% Dual ABI
%% In the GCC 5.1 release libstdc++ introduced a new library ABI that
%% includes new implementations of std::string and std::list. These
%% changes were necessary to conform to the 2011 C++ standard which
%% forbids Copy-On-Write strings and requires lists to keep track of
%% their size. 

%% In order to maintain backwards compatibility for existing code linked
%% to libstdc++ the library's soname has not changed and the old
%% implementations are still supported in parallel with the new ones.
%% This is achieved by defining the new implementations in an inline
%% namespace so they have different names for linkage purposes, e.g. the
%% new version of std::list<int> is actually defined as
%% std::__cxx11::list<int>. Because the symbols for the new
%% implementations have different names the definitions for both versions
%% can be present in the same library. 

%% The \_GLIBCXX\_USE\_CXX11\_ABI macro (see Macros) controls whether the
%% declarations in the library headers use the old or new ABI. So the
%% decision of which ABI to use can be made separately for each source
%% file being compiled. Using the default configuration options for GCC
%% the default value of the macro is 1 which causes the new ABI to be
%% active, so to use the old ABI you must explicitly define the macro to
%% 0 before including any library headers. (Be aware that some GNU/Linux
%% distributions configure GCC 5 differently so that the default value of
%% the macro is 0 and users must define it to 1 to enable the new ABI.) 

%% Although the changes were made for C++11 conformance, the choice of
%% ABI to use is independent of the -std option used to compile your
%% code, i.e. for a given GCC build the default value of the
%% \_GLIBCXX\_USE\_CXX11\_ABI macro is the same for all dialects. This
%% ensures that the -std does not change the ABI, so that it is
%% straightforward to link C++03 and C++11 code together.

%% Because std::string is used extensively throughout the library a
%% number of other types are also defined twice, including the
%% stringstream classes and several facets used by std::locale. The
%% standard facets which are always installed in a locale may be present
%% twice, with both ABIs, to ensure that code like
%% std::use\_facet<std::time_get<char>>(locale); will work correctly for
%% both std::time\_get and std::\_\_cxx11::time\_get (even if a user-defined
%% facet that derives from one or other version of time\_get is installed
%% in the locale). 

%% Although the standard exception types defined in <stdexcept> use
%% strings, they are not defined twice, so that a std::out\_of\_range
%% exception thrown in one file can always be caught by a suitable
%% handler in another file, even if the two files are compiled with
%% different ABIs. 



\subsection{std::string}

Кроме того, что размер std::string поменялся есть еще другие
качественные изменения которые произошли с этими объектами при смене
версии gcc 5.1. Рассмотрим следующий фрагмент
\inputminted{c++}{./src/str.cpp}

GCC 5 дает вполне предсказуемый вывод: мы получаем копию строки со
своими внутренними данными
\begin{minted}{shell}
$ ./str5
0x7ffc757fc1b0
0x7ffc757fc200
$
\end{minted}

Другая ситуация GCC 4:
\begin{minted}{shell}
$ ./str4
0x1d5be88
0x1d5be88
$
\end{minted}

Как видно несмотря на то, что мы взяли копию объекта, реально данные
скопированны не были. GCC 4 использует reference count для
отслеживания ссылок на используемые объекты. Такая реализация была
лишь одной из возможных, и не смотря на плюсы (скорость работы), имела
и свои минусы (???), в частности MS VS использовала другую
методику, которая заключалась в реальном копировании данных.

Все это привело к тому что стадарт языка C++ 2011 который запрещал
использование Copy-On-Write для std::string, что привело к изменению
внутреннего представления этих объектов.

\section{Бинарные внешние библиотеки}

В идеальном варианте внешняя библиотека поставляется в виде исходников
по какой-то из свободных лицензий. В этом случае на целевой
платформе может быть собрана бинарная версия библиотеки, которая будет
совместима со всему другими библиотеками собранными похожим образом.

В проблеатичном случае бинарная библиотека собирается на некоторой
платформе которая отличается от целевой, например Oracle OCCI (???)
собирается с помощью компилятора gcc 4 и рассчитана на применение в
системах RedHat Linux 7. В случае если целевая платформа подразумевает
использование компилятора gcc 5.x вместе с другими библиотеками
собранными этим компилятором (например boost) то возникнут проблемы:
на этапе линковки получаются следующие ошибки

\begin{verbatim}
make tests
gcc -g -O0 -c main.cpp 
docker run --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp gcc:4 \
gcc -shared -fPIC -o libtest4.so -c old.cpp
gcc -g -O0 main.o -o tests -lstdc++ -L. -ltest4
main.o: In function "main":
src/main.cpp:5: undefined reference to 
"test::func(std::__cxx11::basic_string<char, std::char_traits<char>, 
std::allocator<char> >)"
collect2: error: ld returned 1 exit status
Makefile:31: recipe for target "tests" failed
make: *** [tests] Error 1
\end{verbatim}

Для решения этих проблем gcc ABI предлагает реализацию контейнеров
std::list и std::string
удовлетворяющую требованиям стандарта c++ 2011 
 в отдельном namespace, т.е. std::list<int> реально будет 
std::\_\_cxx11::list<int>. Что позволяет использовать две версии ABI в
одной. На уровне исходников выбор версии ABI выбирается с помощью
следующего макроса
\begin{minted}{c++}
#define _GLIBCXX_USE_CXX11_ABI 0
#include <list>
...
// Old ABI be used
std::list<int> l;
...
\end{minted} 

По умолчанию используется (неявно) следующий вариант
\begin{minted}{c++}
#define _GLIBCXX_USE_CXX11_ABI 1
#include <list>
...
// New ABI be used
std::list<int> l;
...
\end{minted} 

Таким образом, если проекту требуется только одна внешняя библиотека с
несовместимы интерфесом которая недоступна в исходных кодах, то все
остальные библиотеки, как и исходный код проекта должны быть собраны в
режиме совместимости со старым ABI: следующий влаг должен быть
добавлен в опции компилятора gcc:
-D\_GLIBCXX\_USE\_CXX11\_ABI=0. 

TBD Conan

Сложнее ситуация когда имеется несколько несовместимых бинарных
библиотек которые должны быть использованы в рамках одного проекта.
В этом случае имеет смысл организовывать взаимодействие с этим
библиотеками с помощью адаптеров, например TBD.

\section{Примеры}

Рассмотрим тестовую библиотеку, которая состоит из интерфейса (API):
old.h
\inputminted{c++}{./src/old.h}
и реализации 
\inputminted{c++}{./src/old.cpp}
сборка осуществляется с помощью следующей команды
\begin{minted}{makefile}
libtest4.so: old.cpp
	docker run --rm -v "$$PWD":/usr/src/myapp -w /usr/src/myapp gcc:4 \
	gcc -shared -fPIC -o libtest4.so -c old.cpp
\end{minted}

Код который использует эту библиотеку выглядит следующим образом: main.cpp
\inputminted{c++}{./src/main.cpp}

Если использовать стандартные опции сборки
\begin{minted}{makefile}
main.o: main.cpp
	gcc -g -O0 -c main.cpp 

tests: main.o libtest4.so
	gcc -g -O0 main.o -o tests -lstdc++ -L. -ltest4
\end{minted}
то получится следующий вывод об ошибке
\begin{verbatim}
make tests
gcc -g -O0 -c main.cpp 
docker run --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp gcc:4 \
gcc -shared -fPIC -o libtest4.so -c old.cpp
gcc -g -O0 main.o -o tests -lstdc++ -L. -ltest4
main.o: In function "main":
src/main.cpp:5: undefined reference to 
"test::func(std::__cxx11::basic_string<char, std::char_traits<char>, 
std::allocator<char> >)"
collect2: error: ld returned 1 exit status
Makefile:31: recipe for target "tests" failed
make: *** [tests] Error 1
\end{verbatim}


Если перевести весь проект на старый ABI, т.е. использовать для сборки
флаг -D\_GLIBCXX\_USE\_CXX11\_ABI=0 то Makefile будет выглядеть
следующим образом
\begin{minted}{makefile}
main.o: main.cpp
	gcc -D_GLIBCXX_USE_CXX11_ABI=0 -g -O0 -c main.cpp

tests: main.o libtest4.so
	gcc -g -O0 main.o -o tests -lstdc++ -L. -ltest4
\end{minted}
и весь проект соберется успешно
\begin{verbatim}
make tests
gcc -D_GLIBCXX_USE_CXX11_ABI=0 -g -O0 -c main.cpp 
docker run --rm -v "$PWD":/usr/src/myapp -w /usr/src/myapp gcc:4 \
gcc -shared -fPIC -o libtest4.so -c old.cpp
gcc -g -O0 main.o -o tests -lstdc++ -L. -ltest4
\end{verbatim}

В качестве альтернативного варианта разработаем адаптер состояший из
следующих файлов - adapter.h:
\inputminted{c++}{./src/adapter.h}
adapterold.cpp:
\inputminted{c++}{./src/adapterold.cpp}
adapter.cpp:
\inputminted{c++}{./src/adapter.cpp}

Сборка теперь осуществляется с помощью следующего Makefile:
\begin{minted}{makefile}
adapter.o: adapter.cpp
	gcc -g -O0 -fPIC -o adapter.o -c adapter.cpp

adapterold.o: adapterold.cpp
	gcc -g -O0 -fPIC -o adapterold.o -c adapterold.cpp

libadapter.so: adapter.o adapterold.o
	gcc -shared -fPIC adapter.o adapterold.o -o libadapter.so 

main.o: main.cpp
	gcc -g -O0 -c main.cpp 

tests: main.o libtest4.so libadapter.so
	gcc -g -O0 main.o -o tests -lstdc++ -L. -ladapter -ltest4
\end{minted}

\section*{Заключение}
Несколько полезных советов по результатам этого исследования. Основной
совет - избегайте использования библиотек, которые недоступны в
исходных кодах. Если это невозможно, то
\begin{enumerate}
\item Пробуйте опции компилятора, такие как
  -D\_GLIBCXX\_USE\_CXX11\_ABI=0
\item Проектируйте использование библиотек через фасады, которые
  скрывают проблемные интерфейсы
\end{enumerate}

\bibliographystyle{gost780s}  %% стилевой файл для оформления по
\bibliography{cppabi}     %% имя библиографической базы (bib-файла)


\end{document}
