%% -*- coding:utf-8 -*-
\chapter{Monads}

Monads are very important for pure functional programming languages
such as Haskell. We will start with formal mathematical definition and
will continue with programming languages examples later.


\section{Monoidal category}

\begin{definition}[Monoidal category]
\label{def:monoidal_category}
A category $\cat{C}$ is called \textit{monoidal category} if it is
equipped with a \mynameref{def:monoid} structure i.e. there are
\begin{itemize}
\item \mynameref{def:bifunctor} $\otimes: \cat{C} \times \cat{C} \tof
  \cat{C}$ called \textit{monoidal product} \index{Monoidal
    product!definition} 
\item an \mynameref{def:object} $id$ called unit object or identity object
\end{itemize}

The elements should satisfy (up to \mynameref{def:isomorphism}) several conditions:
associativity: 
\begin{equation}
A \otimes \left( B \otimes C \right) \cong
  \left( A \otimes B \right) \otimes C
\nonumber
\end{equation}
and $id$ can be treated as left and right identity: 
\begin{eqnarray}
id \otimes A \cong A, 
\nonumber \\
A \otimes id \cong A
\nonumber
\end{eqnarray}
\end{definition}

\begin{definition}[Strict monoidal category]
\label{def:strict_monoidal_category}
TBD
A \mynameref{def:monoidal_category} is said to be strict if the
associator, left 
unitor and right unitors are all identity morphisms. 
\end{definition}

\begin{remark}[Monoidal product]
\label{rem:monoidal_product}
The monoidal product is a binary operation that specifies the exact
monoidal structure. Often it is called as \textit{tensor product} but
we will avoid the naming because it is not always the same as the
\mynameref{def:tensor_product} as it is introduced for
\mynameref{def:hilbert_space}s  
\end{remark}

\begin{definition}[Tensor product]
  \label{def:tensor_product}
  TBD
\end{definition}


\section{Category of endofunctors}

The \mynameref{ex:fun_category} is an example of a category. We can
apply additional limitation and consider only
\mynameref{def:endofunctor}s i.e. we will look at the category
$[\cat{C}, \cat{C}]$ - category of functors from category $\cat{C}$ to
the same category. One of the most popular math definition of a monad
is the following: 
``All told, a monad in X is just a monoid in the category of
endofunctors of X''\cite{bib:maclane71}.
Later we will give an explanation for that one.

\begin{definition}[Monad]
  \label{def:monad}
  The monad $M$ is an \mynameref{def:endofunctor} with 2
  \mynameref{def:nt}s:
  \begin{enumerate}
  \item $\eta: \idf{C} \tont M$
  \item $\mu: M \circ M \tont M$
  \end{enumerate}
  where $\idf{C}$ is \mynameref{def:idfunctor}.

  The $\eta, \mu$ should satisfy the following conditions:
  \begin{eqnarray}
    \mu \circ M \mu = \mu \circ \mu M, 
    \nonumber \\
    \mu \circ M \eta = \mu \circ \eta M = \idnt{M},
    \nonumber
  \end{eqnarray}
  where $M \mu, M \eta$ - \mynameref{def:rw}s, $\mu M, \eta M$ -
  \mynameref{def:lw}s, $\idnt{M}$ - \mynameref{def:idnt} for $M$.
  \mynameref{def:vertical_composition} is used in the equations
  (???TBD verify).

  The monad will be denoted later as $\left<M, \mu, \eta\right>$.
\end{definition}

TBD add monad as monoid

\section{Kleisli category. Monads in programming languages}

\begin{definition}[Kleisli category]
\label{def:kleisli_category}
Let $\cat{C}$ is a category, $M$ is an \mynameref{def:endofunctor} and
$\left<M, \mu, \eta\right>$ is a \mynameref{def:monad}. Then we can
construct a new category $\cat{C_M}$ that is called as \textit{Kleisli
  category} as follows:
\begin{eqnarray}
\catob{C_M} = \catob{C},
\nonumber \\
\hom_{\cat{C_M}}\left(a, b\right) = 
\hom_{\cat{C}}\left(a, M(b)\right)
\nonumber
\end{eqnarray}
i.e. objects of categories $\cat{C}$ and $\cat{C_M}$ are the same but
morphisms from $\cat{C_M}$ form a subset of morphisms $\cat{C_M}$:
$\cathom{C_M} \subset \cathom{C}$.
\end{definition}

TBD

\section{Examples}

\subsection{Programming languages}

\subsubsection{Haskell}

\begin{example}[Monad][\textbf{Hask}]
\label{ex:monad_haskell}
In Haskell monad can be defined from \mynameref{ex:functor_haskell} as follows 
\footnote{real definition is quite different from the presented one}
\begin{minted}{haskell}
    class Functor m => Monad m where
        return :: a -> m a
        (>>=)  :: m a -> (a -> m b) -> m b
\end{minted} 

To show how this one can be get we can start from a definition that is
similar to the math definition:
\begin{minted}{haskell}
    class Functor m => Monad m where
        return :: a -> m a
        join  :: m (m a) -> m a
\end{minted} 
where \mintinline{haskell}{return} can be treated as $\eta$ and 
\mintinline{haskell}{join} as $\mu$. In the case the bind operator 
\mintinline{haskell}{>>=} can be implemented as follows
\begin{minted}{haskell}
(>>=)  :: m a -> (a -> m b) -> m b
ma >>= f = join ( f ma )
\end{minted} 

\end{example}

TBD

\subsubsection{C++}

TBD

\subsubsection{Scala}

\begin{example}[Monad][\textbf{Scala}]
The monad concept is Scala is more close to formal math definition for
\mynameref{def:monad}. It can be defined as follows 
\footnote{real definition is quite different from the presented one}
\label{ex:monad_scala}
\begin{minted}{scala}
trait M[A] {
  def flatMap[B](f: A => M[B]): M[B]
}
  
def unit[A](x: A): M[A]
\end{minted} 
I.e. \mintinline{scala}{flatMap} can be considered as $\mu$ and
\mintinline{scala}{unit} as $\eta$. 
\end{example}

TBD

\subsection{Quantum mechanics}

The tensor product in quantum mechanics is used for
representing a system that consists of multiple systems. For instance
if we have an interaction between an 2 level atom ($a$ is excited
state $b$ as a ground state) and one mode light then the
atom has its own Hilber space $\mathcal{H}_{at}$ with $\ket{a}$ and
$\ket{b}$ as basis 
vectors.  Light also has its own Hilber space $\mathcal{H}_f$ with Fock state
$\{\ket{n}\}$ as the basis.
\footnote{
  Really the $\mathcal{H}_f$ is infinite dimensional Hilber space and
  seems to be out of our assumption about \textbf{FdHilb} category as
  a collection of finite dimensional Hilber spaces only.
}
The result system that describes both atom
and light is represented as the tensor product $\mathcal{H}_{at}
\otimes \mathcal{H}_f$.

The morphisms of \textbf{FdHilb} category have a connection with
\mynameref{def:tensor_product}. Consider the so called Hilbert-Schmidt
correspondence for finite dimensional Hilbert spaces i.e. for given
$\mathcal{A}$ and $\mathcal{B}$ there is a natural isomorphism between
the tensor product and linear maps (aka morphisms) between
$\mathcal{A}$ and $\mathcal{B}$:
\[
\mathcal{A}^\ast \otimes \mathcal{B} \cong \hom(\mathcal{A}, \mathcal{B})
\]
where $\mathcal{A}^\ast$ - \mynameref{def:dual_space}.


TBD
