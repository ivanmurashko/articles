%% -*- coding:utf-8 -*-
\chapter{Objects and morphisms}

\section{Equality}

The important question is how can we decide whenever an
object/morphism is equal to another object/morphism? The trivial
answer is possible for if an \mynameref{def:object} is a
\mynameref{def:set}. In this case we can say that 2 objects are equal
if they contains the same elements. Unfortunately we cannot do the
same for default objects as soon as they don't have any internal
structure. We can use the same trick as in
\mynameref{rem:set_vs_category}: if we cannot use ``microscope'' lets
use ``telescope'' and define the equality of objects and morphisms of
a category $\cat{C}$ in the terms of whole $\cathom{C}$.

\begin{definition}[Objects equality]
\label{def:object_equality}
Two \mynameref{def:object}s $a$ and $b$ in \mynameref{def:category}
$C$ are equal if there exists an unique \mynameref{def:isomorphism}
$f: a \to b$. This also means that also exist unique isomorphism $g: b
\to a$. These two \mynameref{def:morphism}s are related each other via
the following equations: $f \circ g = \idm{a}$ and $g \circ f
= \idm{b}$. 
\end{definition}

Unlike \mynameref{def:function}s between \mynameref{def:set}s we don't
have any additional info 
\footnote{
for instance info about sets internals. i.e. which elements of the sets
are connected by the considered functions
}
about \mynameref{def:morphism}s except
category theory axioms which the morphisms satisfied
\cite{bib:stackexchange:morphism:equality}. This leads us to the
following definition for morphims equality:
\begin{definition}[Morphisms equality]
\label{def:morphism_equality}
Two \mynameref{def:morphism}s $f$ and $g$ in \mynameref{def:category}
$C$ are equal if the equality can be derived from the base axioms: 
\begin{itemize}
\item \mynameref{axm:composition}
\item \mynameref{axm:associativity}
\item \mynameref{def:id}: \eqref{eq:leftid}, \eqref{eq:rightid}
\end{itemize}
or \mynameref{def:commutative_diagram}s which postulate the equality.
\end{definition}

As an example lets proof the following theorem
\begin{theorem}[Identity is unique]
\label{thm:identity_unique}
The \mynameref{def:id} is unique.
\begin{proof}
Consider an \mynameref{def:object} $a$ and it's \mynameref{def:id} 
$\idm{a}$. Let $\exists f: a \to a$ such that $f$ is also
identity. In the case \eqref{eq:leftid} for $f$ as identity gives
\[
f \circ \idm{a} = \idm{a}.
\]
From other side \eqref{eq:rightid} for $\idm{a}$ satisfied
\[
f \circ \idm{a} = f
\]
i.e. $f = \idm{a}$.
\end{proof}
\end{theorem}

\section{Initial and terminal objects}
\begin{definition}[Initial object]
\label{def:initial_object}
Let $\cat{C}$ is a \mynameref{def:category}, the
\mynameref{def:object} $i \in \catob{C}$ is called
\textit{initial object} if $\forall x \in \catob{C}
\exists! f_x: i \to x \in \cathom{C}$.
\end{definition}

\begin{definition}[Terminal object]
\label{def:terminal_object}
Let $\cat{C}$ is a \mynameref{def:category}, the
\mynameref{def:object} $t \in \catob{C}$ is called
\textit{terminal object} if $\forall x \in \catob{C}
\exists! g_x: x \to t \in \cathom{C}$.
\end{definition}

As you can see the initial and terminal objects are opposite each
other. I.e. if $i$ is an \mynameref{def:initial_object} in $\cat{C}$
then it will be \mynameref{def:terminal_object} in
the \mynameref{def:op_category} $\cat{C^{op}}$.

\begin{theorem}[Initial object is unique]
\label{thm:initial_object_unique}
Let $\cat{C}$ is a category and $i, i' \in \catob{C}$ two
\mynameref{def:initial_object}s then there exists an unique
\mynameref{def:isomorphism} $u: i \to i'$ (see
\mynameref{def:object_equality}) 
\begin{proof}
Consider the following \mynameref{def:commutative_diagram} (see
\cref{fig:initial_object_unique}) 
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=above:$i$] (i1) at (0,3) {};    
    \node[ele,label=above:$i'$] (i2) at (3,3) {};    
    \node[ele,label=below:$i$] (i12) at (3,0) {};
    \node[ele,label=below:$i'$] (i22) at (6,0) {};

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (i1) to
    node[sloped,above]{$u$} (i2);
    \draw[->,thick,shorten <=2pt,shorten >=2] (i12) to
    node[sloped,above]{$u$} (i22); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (i1) to
    node[sloped,above]{$\idm{i}$} (i12); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (i2) to
    node[sloped,above]{$\idm{i'}$} (i22); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (i2) to
    node[right]{$u^{-1}$} (i12); 
  \end{tikzpicture}
  \caption{Commutative diagram for initial object unique proof}
  \label{fig:initial_object_unique}
\end{figure}
\end{proof}
\end{theorem}

\begin{theorem}[Terminal object is unique]
\label{thm:terminal_object_unique}
Let $\cat{C}$ is a category and $t, t' \in \catob{C}$ two
\mynameref{def:terminal_object}s then there exists an unique
\mynameref{def:isomorphism} $v: t' \to t$ (see
\mynameref{def:object_equality}) 
\begin{proof}
Just got to the \mynameref{def:op_category} and revert arrows in
\cref{fig:initial_object_unique}. The result shown on
\cref{fig:terminal_object_unique} and it proofs the theorem statement.
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=above:$t$] (t1) at (0,3) {};    
    \node[ele,label=above:$t'$] (t2) at (3,3) {};    
    \node[ele,label=below:$t$] (t12) at (3,0) {};
    \node[ele,label=below:$t'$] (t22) at (6,0) {};

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (t2) to
    node[sloped,above]{$v$} (t1);
    \draw[->,thick,shorten <=2pt,shorten >=2] (t22) to
    node[sloped,above]{$v^{-1}$} (t12); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (t12) to
    node[sloped,above]{$\idm{t}$} (t1); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (t22) to
    node[sloped,above]{$\idm{t'}$} (t2); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (t12) to
    node[right]{$v^{-1}$} (t2); 
  \end{tikzpicture}
  \caption{Commutative diagram for terminal object unique proof}
  \label{fig:terminal_object_unique}
\end{figure}
\end{proof}
\end{theorem}


\section{Product and sum}
The pair of 2 objects is defined via so called universal property in
the following way:
\begin{definition}[Product]
\label{def:product}
Let we have a category $\cat{C}$ and $c_1, c_2 \in \catob{C}$ -two
\mynameref{def:object}s the product of the objects $c_1, c_2$ is
another object in $\cat{C}$ $c = c_1 \times c_2$ with 2
\mynameref{def:morphism}s $\pi_1, \pi_2$ such that $a = g_a c, b = g_b
c$ and the 
following universal property is satisfied: $\forall c' \in \catob{C}$
and morphisms $\pi'_1: \pi'_2 c' = c_1, \pi'_2: \pi'_2 c' = c_2$, exists unique
morphism $h$ such that the following diagram (see \cref{fig:product})
commutes, i.e. $\pi'_1 = \pi_1 \circ h, \pi'_2 = \pi_2 \circ h$.
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=left:$c_1$] (a) at (0,0) {};    
    \node[ele,label=right:$c_2$] (b) at (4,0) {};    
    \node[ele,label=below:$c$] (c) at (2,0) {};
    \node[ele,label=above:$c'$] (c') at (2,3) {};

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (c) to
    node[sloped,above]{$\pi_1$} (a);
    \draw[->,thick,shorten <=2pt,shorten >=2] (c) to
    node[sloped,above]{$\pi_2$} (b); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (c') to
    node[sloped,above]{$\pi'_1$} (a); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (c') to
    node[sloped,above]{$\pi'_2$} (b); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (c') to
    node[right]{$h$} (c); 
  \end{tikzpicture}
  \caption{Product $c = c_1 \times c_2$. $\forall c, \exists! h \in
    \cathom{C}: \pi'_1 = \pi_1 \circ h, \pi'_2 = \pi_2 \circ h$.}
  \label{fig:product}
\end{figure}
In other words $h$ factorizes $\pi'_{1,2}$.
\end{definition}

If we invert arrows in \mynameref{def:product} we will got another
object definition that is called sum

\begin{definition}[Sum]
\label{def:sum}
Let we have a category $\cat{C}$ and $c_1, c_2 \in \catob{C}$ -two
\mynameref{def:object}s the sum of the objects $c_1, c_2$ is
another object in $\cat{C}$ $c = c_1 \oplus c_2$ with 2
\mynameref{def:morphism}s $i_1, i_2$ such that $c = i_1 c_1, c = i_2
c_2$ and the 
following universal property is satisfied: $\forall c' \in \catob{C}$
and morphisms $i'_1: i'_1 x_1 = c', i'_2: i'_2 x_2 = c'$, exists unique
morphism $h$ such that the following diagram (see \cref{fig:sum})
commutes, i.e. $i'_1 = h \circ i_1, i'_2 = h \circ i_2$.
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=left:$c_1$] (a) at (0,0) {};    
    \node[ele,label=right:$c_2$] (b) at (4,0) {};    
    \node[ele,label=below:$c$] (c) at (2,0) {};
    \node[ele,label=above:$c'$] (c') at (2,3) {};

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (a) to
    node[sloped,above]{$i_1$} (c);
    \draw[->,thick,shorten <=2pt,shorten >=2] (b) to
    node[sloped,above]{$i_2$} (c); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (a) to
    node[sloped,above]{$i'_1$} (c'); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (b) to
    node[sloped,above]{$i'_2$} (c'); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (c) to
    node[right]{$h$} (c'); 
  \end{tikzpicture}
  \caption{Sum $c = c_1 \oplus c_2$. $\forall c, \exists! h \in
    \cathom{C}: i'_1 = h \circ i_1, i'_2 = h \circ i_2 $.}
  \label{fig:sum}
\end{figure}
In other words $h$ factorizes $i'_{1,2}$.
\end{definition}

\section{Category as monoid}
Consider the following definition from abstract algebra
\begin{definition}[Monoid]
  \label{def:monoid}
  The set of elements $M$ with defined binary operation $\circ$ we will call
  as a monoid if the following conditions are satisfied.
  \begin{enumerate}
  \item Closure: $\forall a, b \in M$: $a \circ b \in M$
  \item Associativity: $\forall a, b, c \in M$:
    $a \circ \left( b \circ c \right) =
    \left( a \circ b \right) \circ c$
  \item Identity element: $\exists e \in M$ such that
    $\forall a \in M$: $e \circ a = a \circ e = a$
  \end{enumerate}
\end{definition}

We can consider 2 \mynameref{def:monoid}s. The firs one has
\mynameref{def:product} as the binary operation and
\mynameref{def:terminal_object} as the identity element. As result we
just got an analog of multiplication in the category theory. This is why
the terminal object is often called as $\mathbf{1}$ and the operation
as the product. 

Another one is additional \mynameref{def:monoid} that has
\mynameref{def:initial_object} as the identity element and the
\mynameref{def:sum} as the binary operation. The initial object in
that case  is often called as $\mathbf{0}$. I.e. we can see a direct
connection with addition in algebra.

\section{Exponential}
TBD

\section{Programming languages and algebraic data types}
TBD

\section{Examples}

\subsection{\textbf{Set} category}
\begin{example}[Initial object][\textbf{Set}]
\label{ex:set_initial_object}
Note that there is only one function from empty set to any other sets
\cite{bib:proofwiki:Empty_Mapping_is_Unique} that makes the empty set
as the \mynameref{def:initial_object} in \mynameref{def:setcategory}. 
\end{example}

\begin{example}[Terminal object][\textbf{Set}]
\label{ex:set_terminal_object}
\mynameref{def:terminal_object} in \mynameref{def:setcategory} is a set
with one element i.e \mynameref{def:singleton_set}. 
\end{example}

\begin{example}[Product][\textbf{Set}]
\label{ex:set_product}
The \mynameref{def:product} of two sets $A$ and $B$ in
\mynameref{def:setcategory} is defined 
as a Cartesian product: $A \times B = \{(a,b)| a \in A, b \in B\}$. 
\end{example}

\begin{example}[Sum][\textbf{Set}]
  \label{ex:set_sum}
  \index{Disjoint union}
  The \mynameref{def:sum} of two sets $A$ and $B$ in
  \mynameref{def:setcategory} is defined as disjoint union
  \cite{wiki:disjointunion}. Let $\{A_i: i \in I\}$ be a family of sets 
  indexed by $I$. The 
  disjoint union of this family is the set
  \[
  \sqcup_{i \in I} A_i = \cup_{i \in I}\left\{
  \left(x, i\right): x \in A_i
  \right\}.
  \]
  The elements of the disjoint union are ordered pairs $(x, i)$. Here $i$
  serves as an auxiliary index that indicates which Ai the element $x$
  came from.
\end{example}

\subsection{Programming languages}
In our toy example \cref{fig:pl_example} the type String is
\mynameref{def:initial_object} and type Bool is the
\mynameref{def:terminal_object}. From other side there are types in
different programming languages that satisfies the definitions of
initial and terminal objects.

\subsubsection{\textbf{Hask} category}
\begin{example}[Initial object][\textbf{Hask}]
If we avoid lazy evaluations in Haskell (see
\mynameref{rem:hask_lazy_eval}) then we can found the following types
as candidates for initial and terminal object in haskell. 
\label{ex:hask_initial_object}
\mynameref{def:initial_object} in \mynameref{def:haskcategory} is a
type without values 
\begin{minted}{haskell}
data Void
\end{minted}
i.e. you cannot construct a object of the type.

There is only one function from the initial object:
\begin{minted}{haskell}
absurd :: Void -> a
\end{minted}
The function is called absurd because it does absurd action. Nobody
can proof that it does not exist. For the existence proof can be used
the following absurd argument: ``Just provide me an object type
\mintinline{haskell}{Void} and I will provide you the result of
evaluation''.  

There is no function in opposite direction because it would had been
used for the \mintinline{haskell}{Void} object creation. 
\end{example}

\begin{example}[Terminal object][\textbf{Hask}]
\label{ex:hask_terminal_object}
Terminal object (unit) in \mynameref{def:haskcategory} keeps only one element
\begin{minted}{haskell}
data () = ()
\end{minted}
i.e. you can create only one element of the type. You can use the
following function for the creation:
\begin{minted}{haskell}
unit :: a -> ()
unit _ = ()
\end{minted}
\end{example}

\begin{example}[Product][\textbf{Hask}]
\label{ex:hask_product}
The \mynameref{def:product} in \mynameref{def:haskcategory} keeps a
pair and the constructor defined as follows
\begin{minted}{haskell}
(,) :: a -> b -> (a, b)
(,) x y = (x, y)
\end{minted}
There are 2 projectors: 
\begin{minted}{haskell}
fst :: (a, b) -> a
fst (x, _) = x
snd :: (a, b) -> b
snd (_, y) = y
\end{minted}
\end{example}

\begin{example}[Sum][\textbf{Hask}]
\label{ex:hask_sum}
The \mynameref{def:sum} in \mynameref{def:haskcategory} defined as
follows 
\begin{minted}{haskell}
data Either a b = Left a | Right b
\end{minted}

The typical usage is via pattern matching for instance 
\begin{minted}{haskell}
factor :: (a -> c) -> (b -> c) -> Either a b -> c
factor f _ (Left x) = f x
factor _ g (Right y) = g y
\end{minted}
\end{example}


\subsubsection{\textbf{C++} category}
\begin{example}[Initial object][\textbf{C++}]
\label{ex:cpp_initial_object}
In C++ exists a special type that does not hold any values and as
result that cannot be created: \mintinline{c++}{void}.
You cannot create an object of that type: you will get a compiler
error if you try.
\end{example}

\begin{example}[Terminal object][\textbf{C++}]
\label{ex:cpp_terminal_object}
C++ 17 introduced a special type that keeps only one value -
\mintinline{c++}{std::monostate}:  
\begin{minted}{c++}
namespace std {
  struct monostate {};
}
\end{minted}
\end{example}

\begin{example}[Product][\textbf{C++}]
\label{ex:cpp_product}
The \mynameref{def:product} in \mynameref{def:cppcategory} keeps a
pair and the constructor defined as follows
\begin{minted}{c++}
namespace std {
  template< class A, class B > struct pair {
    T1 first;
    T2 second;
  };
}
\end{minted}

There is a simple usage example
\begin{minted}{c++}
  std::pair<int, bool> p(0, false);

  std::cout << "First projector: " << p.first << std::endl;
  std::cout << "Second projector: " << p.second << std::endl;

\end{minted}
Really any \mintinline{c++}{struct} or \mintinline{c++}{class} can be
considered as the product. 
\end{example}

\begin{example}[Sum][\textbf{C++}]
  \label{ex:cpp_sum}
  If we consider \mynameref{def:object}s as types then
  \mynameref{def:sum} is an object that can be either one or another
  type. The corresponding C/C++ construction that provides an ability
  to keep one of two types is \mintinline{c++}{union}. 

  %% There is an \mintinline{haskell}{Either} implementation from
  %% \mynameref{ex:hask_sum} 
  %% \begin{minted}{c++}
  %%   template <typename A, typename B> class Either
  %%   {
  %%   public:
  %%     Either(const Either& e) : is_left_(e.is_left_){
  %%       if (is_left_){
  %%         data.l = e.data.l;      
  %%       } else {
  %%         data.r = e.data.r;      
  %%       }    
  %%     }
  %%     ~Either(){
  %%       if (is_left_){
  %%         data.l.~A();      
  %%       } else {
  %%         data.r.~B();      
  %%       }        
  %%     }      
  %%     Either(const A& l) : data(l), is_left_(true){
  %%     }
  %%     Either(const B& r) : data(r), is_left_(false){
  %%     }
  %%     const A& left() const {
  %%       if (!is_left_){
  %%         throw std::logic_error("no left");      
  %%       }    
  %%       return data.l;    
  %%     }
  %%     const B& right() const {
  %%       if (is_left_){
  %%         throw std::logic_error("no right");      
  %%       }    
  %%       return data.r;    
  %%     }
  %%   private:
  %%     union Data {
  %%       Data() {}
  %%       Data( const A& a) : l(a) {}
  %%       Data (const B& b) : r(b) {}
  %%       ~Data() {}
  %%       A l;
  %%       B r;
  %%     } data;       
  %%     bool is_left_;  
  %%   };
  %% \end{minted}
  %% The usage example:
  %% \begin{minted}{c++}
  %%   template <typename A, typename B, typename C, typename D>
  %%   auto factor(A f, B g, const Either<C, D>& either) {
  %%     try {
  %%       return f(either.left());               
  %%     }
  %%     catch(...) {
  %%       return g(either.right());                              
  %%     }
  %%   };
    
  %%   auto stringLength = [](std::string s) {
  %%     return static_cast<int>(s.size()); };
  %%   auto id = [](auto x) { return x; };
          
  %%   Either<std::string, int> str = std::string("abc");
  %%   std::cout << "String length:" <<
  %%   factor<>(stringLength, id, str) << std::endl;
  %%   Either<std::string, int> i = 4;
  %%   std::cout << "id(int):" <<
  %%   factor<>(stringLength, id, i) << std::endl;
  %% \end{minted}

  C++17 suggests \mintinline{c++}{std:variant} as a safe replacement
  for \mintinline{c++}{union}. The example of the \mintinline{c++}{factor}
  function is below
  \begin{minted}{c++}
    template <typename A, typename B, typename C, typename D>
    auto factor(A f, B g, const std::variant<C, D>& either) {
      try {
        return f(std::get<C>(either));               
      }
      catch(...) {
        return g(std::get<D>(either));                              
      }
    };
  \end{minted}
  The simple usage as follows:
  \begin{minted}{c++}
    std::variant<std::string, int> var = std::string("abc");
    std::cout << "String length:" <<
    factor<>(stringLength, id, var) << std::endl;
    var = 4;
    std::cout << "id(int):" <<
    factor<>(stringLength, id, var) << std::endl;    
  \end{minted}

\end{example}
TBD
\subsubsection{\textbf{Scala} category}
\begin{example}[Initial object][\textbf{Scala}]
\label{ex:scala_initial_object}
We used a same trick as for \mynameref{ex:hask_initial_object} and define
\mynameref{def:initial_object} in \mynameref{def:scalacategory} as a
type without values 
\begin{minted}{scala}
sealed trait Void
\end{minted}
i.e. you cannot construct a object of the type.
\end{example}

\begin{example}[Terminal object][\textbf{Scala}]
\label{ex:scala_terminal_object}
We used a same trick as for \mynameref{ex:hask_terminal_object} and define
\mynameref{def:terminal_object} in \mynameref{def:scalacategory} as a
type with only one value
\begin{minted}{scala}
abstract final class Unit extends AnyVal
\end{minted}
TBD
i.e. you can create only one element of the type.
\end{example}

TBD

\subsection{Quantum mechanics}
\begin{example}[Initial object][\textbf{FdHilb}]
\label{ex:quant_initial_object}
We will use a Hilber space of dimensional 0 as the
\mynameref{def:initial_object}. I.e. the set that does not have any
states in it.
\end{example}

\begin{example}[Terminal object][\textbf{FdHilb}]
  \label{ex:quant_terminal_object}
We will use a Hilber space of dimensional 1 as the
\mynameref{def:terminal_object}. I.e. the set of complex numbers
$\mathbb{C}$.   
\end{example}

\begin{example}[Product][\textbf{FdHilb}]
  \label{ex:quant_product}
  The \mynameref{def:product} in \mynameref{def:fdhilbcategory} is a
  \mynameref{def:fdhilb_direct_sum}.
\end{example}

\begin{example}[Sum][\textbf{FdHilb}]
  \label{ex:quant_sum}
  The \mynameref{def:sum} in \mynameref{def:fdhilbcategory} is a
  \mynameref{def:fdhilb_direct_sum}.
\end{example}

TBD

