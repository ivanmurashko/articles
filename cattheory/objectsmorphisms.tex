%% -*- coding:utf-8 -*-
\chapter{Objects and morphisms}

\section{Equality}

The important question is how can we decide whenever an
object/morphism is equal to another object/morphism? The trivial
answer is possible if an \mynameref{def:object} is a
\mynameref{def:set}. In the case we can say that 2 objects are equal
if they contain the equivalent collection of elements. Unfortunately
we cannot do the same trick for categorical \mynameref{def:object}s as
soon as they don't have any internal 
structure but can use a similar approach as in
\mynameref{rem:set_vs_category}: if we cannot use ``microscope'' lets
use ``telescope'' and define the equality of objects and morphisms of
a category $\cat{C}$ in the terms of whole $\cathom{C}$.

\begin{definition}[Objects equality]
\label{def:object_equality}
Two \mynameref{def:object}s $a$ and $b$ in \mynameref{def:category}
$\cat{C}$ are equal if there exists an unique
\mynameref{def:isomorphism} $a \cong_f b$. This also means that
also exist unique isomorphism $b \cong_g a$. These two
\mynameref{def:morphism}s ($f$ and $g$) are related each other via 
the following equations: $f \circ g = \idm{a}$ and $g \circ f
= \idm{b}$. 
\end{definition}

Unlike \mynameref{def:function}s between \mynameref{def:set}s we don't
have any additional info 
\footnote{
for instance info about sets internals. i.e. which elements of the sets
are connected by the considered functions
}
about \mynameref{def:morphism}s except
category theory axioms which the morphisms satisfy 
\cite{bib:stackexchange:morphism:equality}. This leads us to the
following definition of morphims equality:
\begin{definition}[Morphisms equality]
\label{def:morphism_equality}
Two \mynameref{def:morphism}s $f$ and $g$ in \mynameref{def:category}
$\cat{C}$ are equal if the equality can be derived from the base axioms: 
\begin{itemize}
\item \mynameref{axm:composition}
\item \mynameref{axm:associativity}
\item \mynameref{def:id}: \eqref{eq:leftid}, \eqref{eq:rightid}
\end{itemize}
or \mynameref{def:commutative_diagram}s which postulate the equality.
\end{definition}
As an example lets proof the following theorem
\begin{theorem}[Identity is unique]
\label{thm:identity_unique}
The \mynameref{def:id} is unique.
\begin{proof}
Consider an \mynameref{def:object} $a$ and it's \mynameref{def:id} 
$\idm{a}$. Let $\exists f: a \to a$ such that $f$ is also
identity. In the case \eqref{eq:leftid} for $f$ as identity gives
\[
f \circ \idm{a} = \idm{a}.
\]
From other side \eqref{eq:rightid} for $\idm{a}$ satisfied
\[
f \circ \idm{a} = f
\]
i.e.
\[
f = f \circ \idm{a} = \idm{a}
\] 
or
$f = \idm{a}$.
\end{proof}
\end{theorem}

\section{Initial and terminal objects}
\begin{definition}[Initial object]
\label{def:initial_object}
Let $\cat{C}$ is a \mynameref{def:category}, the
\mynameref{def:object} $i \in \catob{C}$ is called
\textit{initial object} if $\forall x \in \catob{C}
\exists! f_x: i \to x \in \cathom{C}$.
\end{definition}

\begin{definition}[Terminal object]
\label{def:terminal_object}
Let $\cat{C}$ is a \mynameref{def:category}, the
\mynameref{def:object} $t \in \catob{C}$ is called
\textit{terminal object} if $\forall x \in \catob{C}
\exists! g_x: x \to t \in \cathom{C}$.
\end{definition}

As you can see the initial and terminal objects are opposite each
other. I.e. if $i$ is an \mynameref{def:initial_object} in $\cat{C}$
then it will be \mynameref{def:terminal_object} in
the \mynameref{def:op_category} $\cat{C^{op}}$.

\begin{theorem}[Initial object is unique]
\label{thm:initial_object_unique}
Let $\cat{C}$ is a category and $i, i' \in \catob{C}$ two
\mynameref{def:initial_object}s then there exists an unique
\mynameref{def:isomorphism} $u: i \to i'$ (see
\mynameref{def:object_equality}) 
\begin{proof}
Consider the following \mynameref{def:commutative_diagram} (see
\cref{fig:initial_object_unique}). As soon as $i$ initial object
$\exists! \, u: i \to i'$. From other side $i'$ is also initial object
and therefore $\exists! \, u^{-1}: i' \to i$. Combining them together
via composition we can get $u^{-1} \circ u: i \to i$ and $u \circ
u^{-1}: i' \to i'$. From the fact that $i$ is initial object one can
get that there exists
only one morphism $\idm{i}: i \to i$. The same is the truth for $i'$.
Therefore $u^{-1} \circ u = \idm{i}$ and $u \circ u^{-1} = \idm{i'}$.
These complete the commutative diagram build and finishes the proof. 
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=above:$i$] (i1) at (0,3) {};    
    \node[ele,label=above:$i'$] (i2) at (3,3) {};    
    \node[ele,label=below:$i$] (i12) at (3,0) {};
    \node[ele,label=below:$i'$] (i22) at (6,0) {};

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (i1) to
    node[sloped,above]{$u$} (i2);
    \draw[->,thick,shorten <=2pt,shorten >=2] (i12) to
    node[sloped,above]{$u$} (i22); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (i1) to
    node[sloped,above]{$\idm{i}$} (i12); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (i2) to
    node[sloped,above]{$\idm{i'}$} (i22); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (i2) to
    node[right]{$u^{-1}$} (i12); 
  \end{tikzpicture}
  \caption{Commutative diagram for initial object uniqueness  proof}
  \label{fig:initial_object_unique}
\end{figure}
\end{proof}
\end{theorem}

\begin{theorem}[Terminal object is unique]
\label{thm:terminal_object_unique}
Let $\cat{C}$ is a category and $t, t' \in \catob{C}$ two
\mynameref{def:terminal_object}s then there exists an unique
\mynameref{def:isomorphism} $v: t' \to t$ (see
\mynameref{def:object_equality}) 
\begin{proof}
Just got to the \mynameref{def:op_category} and revert arrows in
\cref{fig:initial_object_unique}. The result shown on
\cref{fig:terminal_object_unique} and it proofs the theorem statement.
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=above:$t$] (t1) at (0,3) {};    
    \node[ele,label=above:$t'$] (t2) at (3,3) {};    
    \node[ele,label=below:$t$] (t12) at (3,0) {};
    \node[ele,label=below:$t'$] (t22) at (6,0) {};

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (t2) to
    node[sloped,above]{$v$} (t1);
    \draw[->,thick,shorten <=2pt,shorten >=2] (t22) to
    node[sloped,above]{$v^{-1}$} (t12); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (t12) to
    node[sloped,above]{$\idm{t}$} (t1); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (t22) to
    node[sloped,above]{$\idm{t'}$} (t2); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (t12) to
    node[right]{$v^{-1}$} (t2); 
  \end{tikzpicture}
  \caption{Commutative diagram for terminal object uniqueness proof}
  \label{fig:terminal_object_unique}
\end{figure}
\end{proof}
\end{theorem}


\section{Product and sum}
The pair of 2 objects is defined via the universal property in
the following way:
\begin{definition}[Product]
\label{def:product}
Let we have a category $\cat{C}$ and $c_1, c_2 \in \catob{C}$ -two
\mynameref{def:object}s then the product of the objects $c_1, c_2$ is
another object in $\cat{C}$ $c = c_1 \times c_2$ with 2
\mynameref{def:morphism}s $\pi_1, \pi_2$ such that $c_1 = \pi_1(c),
c_2 = \pi(c_2)$ and the  
following universal property is satisfied: $\forall c' \in \catob{C}$
and morphisms $\pi'_1: c' \to c_1, \pi'_2: c' \to c_2$, exists unique
morphism $h$ such that the following diagram (see \cref{fig:product})
commutes, i.e. $\pi'_1 = \pi_1 \circ h, \pi'_2 = \pi_2 \circ h$.
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=left:$c_1$] (a) at (0,0) {};    
    \node[ele,label=right:$c_2$] (b) at (4,0) {};    
    \node[ele,label=below:$c$] (c) at (2,0) {};
    \node[ele,label=above:$c'$] (c') at (2,3) {};

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (c) to
    node[sloped,above]{$\pi_1$} (a);
    \draw[->,thick,shorten <=2pt,shorten >=2] (c) to
    node[sloped,above]{$\pi_2$} (b); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (c') to
    node[sloped,above]{$\pi'_1$} (a); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (c') to
    node[sloped,above]{$\pi'_2$} (b); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (c') to
    node[right]{$h$} (c); 
  \end{tikzpicture}
  \caption{Product $c = c_1 \times c_2$. $\forall c, \exists! h \in
    \cathom{C}: \pi'_1 = \pi_1 \circ h, \pi'_2 = \pi_2 \circ h$.}
  \label{fig:product}
\end{figure}
In other words $h$ factorizes $\pi'_{1,2}$.
\end{definition}

If we invert arrows in \mynameref{def:product} we will got another
object definition that is called sum

\begin{definition}[Sum]
\label{def:sum}
Let we have a category $\cat{C}$ and $c_1, c_2 \in \catob{C}$ -two
\mynameref{def:object}s then the sum of the objects $c_1, c_2$ is
another object in $\cat{C}$ $c = c_1 \oplus c_2$ with 2
\mynameref{def:morphism}s $i_1, i_2$ such that $c = i_1(c_1), c = i_2
(c_2)$ and the 
following universal property is satisfied: $\forall c' \in \catob{C}$
and morphisms $i'_1: c_1 \to c', i'_2: c_2 \to c'$, exists unique
morphism $h$ such that the following diagram (see \cref{fig:sum})
commutes, i.e. $i'_1 = h \circ i_1, i'_2 = h \circ i_2$.
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=left:$c_1$] (a) at (0,0) {};    
    \node[ele,label=right:$c_2$] (b) at (4,0) {};    
    \node[ele,label=below:$c$] (c) at (2,0) {};
    \node[ele,label=above:$c'$] (c') at (2,3) {};

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (a) to
    node[sloped,above]{$i_1$} (c);
    \draw[->,thick,shorten <=2pt,shorten >=2] (b) to
    node[sloped,above]{$i_2$} (c); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (a) to
    node[sloped,above]{$i'_1$} (c'); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (b) to
    node[sloped,above]{$i'_2$} (c'); 
    \draw[->,thick,shorten <=2pt,shorten >=2] (c) to
    node[right]{$h$} (c'); 
  \end{tikzpicture}
  \caption{Sum $c = c_1 \oplus c_2$. $\forall c, \exists! h \in
    \cathom{C}: i'_1 = h \circ i_1, i'_2 = h \circ i_2 $.}
  \label{fig:sum}
\end{figure}
In other words $h$ factorizes $i'_{1,2}$.
\end{definition}

The \mynameref{def:product} of objects will provide also a definition
for product of morphisms
\begin{definition}[Product of morphisms]
\label{def:product_of_morphisms}
Let $\cat{C}$ is a category and $a,a' \in \catob{C}$ and 
$b, b' \in \catob{C}$ are 2 pairs of \mynameref{def:object}s that admit
\cref{def:product}. Consider 2 morphisms that connects the objects: 
$f: a \to b, f': a' \to b'$ then we can create a new unique morphism that
connects the products: $f \times f': a \times a' \to b \times b'$ and
makes the diagram commute (see \cref{fig:product_of_morphisms}). 

\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=above:$a$] (a) at (0,2) {};    
    \node[ele,label=above:$a \times a'$] (aa') at (2,2) {};    
    \node[ele,label=above:$a'$] (a') at (4,2) {};    
    \node[ele,label=below:$b$] (b) at (0,0) {};    
    \node[ele,label=below:$b \times b'$] (bb') at (2,0) {};    
    \node[ele,label=below:$b'$] (b') at (4,0) {};    

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (a) to
    node[sloped,above]{$f$} (b);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (a') to
    node[sloped,above]{$f'$} (b');
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (aa') to
    node[sloped,above]{$f \times f'$} (bb');


    \draw[->,thick,shorten <=2pt,shorten >=2pt] (aa') to
    node[sloped,above]{$\pi_a$} (a);
    \draw[->,thick,shorten <=2pt,shorten >=2] (aa') to
    node[sloped,above]{$\pi_{a'}$} (a'); 
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (bb') to
    node[sloped,above]{$\pi_b$} (b);
    \draw[->,thick,shorten <=2pt,shorten >=2] (bb') to
    node[sloped,above]{$\pi_{b'}$} (b'); 
  \end{tikzpicture}
  \caption{Product of morphisms.}
  \label{fig:product_of_morphisms}
\end{figure}
\end{definition} 

\section{Category as a monoid}
Consider the following definition from abstract algebra
\begin{definition}[Monoid]
  \label{def:monoid}
  The set of elements $M$ with defined binary operation $\circ$ we will call
  as a monoid if the following conditions are satisfied.
  \begin{enumerate}
  \item Closure: $\forall a, b \in M$: $a \circ b \in M$
  \item Associativity: $\forall a, b, c \in M$:
    $a \circ \left( b \circ c \right) =
    \left( a \circ b \right) \circ c$
  \item Identity element: $\exists e \in M$ such that
    $\forall a \in M$: $e \circ a = a \circ e = a$
  \end{enumerate}
\end{definition}

We can consider 2 \mynameref{def:monoid}s. The first one has
\mynameref{def:product} as the binary operation and
\mynameref{def:terminal_object} as the identity element. As result we
just got an analog of multiplication in the category theory. This is why
the terminal object is often denoted as $\mathbf{1}$ and the operation
is called as the product. 

Another one is additional \mynameref{def:monoid} that has
\mynameref{def:initial_object} as the identity element and the
\mynameref{def:sum} as the binary operation. The initial object in
that case  is often denoted as $\mathbf{0}$. I.e. we can see a direct
connection with addition in algebra.


\section{Exponential}
TBD

\section{Programming languages and algebraic data types}
TBD

\section{Examples}

\subsection{\textbf{Set} category}
\begin{example}[Initial object][\textbf{Set}]
\label{ex:set_initial_object}
Note that there is only one function from empty set to any other sets
\cite{bib:proofwiki:Empty_Mapping_is_Unique} that makes the empty set
as the \mynameref{def:initial_object} in \mynameref{def:setcategory}. 
\end{example}

\begin{example}[Terminal object][\textbf{Set}]
\label{ex:set_terminal_object}
\mynameref{def:terminal_object} in \mynameref{def:setcategory} is a set
with one element i.e \mynameref{def:singleton_set}. 
\end{example}

\begin{example}[Product][\textbf{Set}]
\label{ex:set_product}
The \mynameref{def:product} of two sets $A$ and $B$ in
\mynameref{def:setcategory} is defined 
as a Cartesian product: $A \times B = \{(a,b)| a \in A, b \in B\}$. 
\end{example}

\begin{definition}[Disjoint union]
  \label{def:disjoint_union}
  Let $\{A_i: i \in I\}$ be a family of sets 
  indexed by $I$. The 
  \textit{disjoint union} \cite{wiki:disjointunion} of this family is
  the set 
  \[
  \sqcup_{i \in I} A_i = \cup_{i \in I}\left\{
  \left(x, i\right): x \in A_i
  \right\}.
  \]
  The elements of the disjoint union are ordered pairs $(x, i)$. Here $i$
  serves as an auxiliary index that indicates which $A_i$ the element $x$
  came from.
\end{definition}

\begin{example}[Sum][\textbf{Set}]
  \label{ex:set_sum}
  The \mynameref{def:sum} of two sets $A$ and $B$ in
  \mynameref{def:setcategory} is defined as
  \mynameref{def:disjoint_union}.  
\end{example}

\subsubsection{Monoid}
Lets consider \mynameref{def:monoid} in the terms of Set theory and
will try to give the definition that is based rather on morphisms then
on internal set structure. Consider a set $M$ and by the definition
$\forall m_1, m_2 \in M$ we can define a new element of the set
$\mu(m_1, m_2) \in M$. Later we will use the following notation for
the $\mu$:
\[
\mu(m_1, m_2) \equiv m_1 \cdot m_2.
\]
If the $(M, \cdot)$ is monoid then the following 2 conditions have to
be satisfied. The first one (associativity) declares that $\forall
m_1, m_2, m_3 \in M$ 
\[
m_1 \cdot ( m_2 \cdot m_3) = ( m_1 \cdot
m_2 ) \cdot m_3.
\]
The second one (identity presence) says that
\(
\exists e \in M
\) such that $\forall m \in M$:
\begin{equation}
m \cdot e = e \cdot m = m.
\label{eq:monoid2}
\end{equation}

Lets start with the first one we can define $\mu$ as
\mynameref{def:morphism} in the following way $\mu: M\times M \to M$
where $M \times M$ is \mynameref{ex:set_product} in
\mynameref{def:setcategory}. I.e. $M, M \times M \in \catob{Set}$ and
$\mu \in \cathom{Set}$.  Consider another objects of $\cat{Set}$: $A =
M \times \left( M \times M \right)$ and $A' = \left( M \times M \right)
\times M$. They are not the same but there is a trivial
\mynameref{def:isomorphism} between them $A \cong_\alpha A'$, where
\[
\alpha(x,(y,z)) = ((x,y),z).
\]
Consider the action of \mynameref{def:product_of_morphisms} 
$\idm{M} \times \mu$ on $A$:
\[
\idm{M} \times \mu \left(x,\left(y,z\right)\right) = 
\left(\idm{M}(x),\mu\left(y,z\right)\right) = 
\left(x, y \cdot z\right) \in M \times M
\]
i.e. $\idm{M} \times \mu: M \times \left( M \times M \right) \to M
\times M$. If we act $\mu$ on the result we will get:
\begin{eqnarray}
\mu \left(\idm{M} \times \mu \left(x,\left(y,z\right)\right)\right) = 
\left(\idm{M}(x),\mu\left(y,z\right)\right) = 
\nonumber \\
=
\mu\left(x, y \cdot z\right) = x \cdot (y\cdot z) \in M,
\nonumber
\end{eqnarray}
i.e. 
$\mu \circ \left(\idm{M} \times \mu\right): M \times \left( M \times M
\right) \to M$.

For $A'$ we have the following one:
\begin{eqnarray}
\mu\circ\left(\mu \times \idm{M}\right)\left(\left(x,y\right),z\right)
= \mu\left(x \cdot y, z\right) = (x \cdot y) \cdot z.
\nonumber
\end{eqnarray}
Monoid associativity requires 
\[
x \cdot (y\cdot z) = 
(x \cdot y) \cdot z
\]
i.e. the morphisms the corresponding morphisms commute:
\[
\mu\circ\left(\mu \times \idm{M}\right) =
\mu \circ \left(\idm{M} \times \mu\right) \circ \alpha.
\]
This corresponds the diagram is at \cref{fig:monoid_mu_alpha}.

\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=above:$M\times\left(M \times M\right)$] (M31) at (0,3) {};    
    \node[ele,label=above:$\left(M \times M\right)\times M$] (M32) at (6,3) {};    
    \node[ele,label=below:$M \times M$] (M21) at (0,0) {};    
    \node[ele,label=below:$M \times M$] (M22) at (6,0) {};    
    \node[ele,label=below:$M$] (M) at (3,0) {};    

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M31) to
    node[sloped,above]{$\alpha$} (M32);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M31) to
    node[sloped,below]{$\idm{M} \times \mu$} (M21);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M32) to
    node[sloped,below]{$\mu \times \idm{M}$} (M22);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M22) to
    node[sloped,above]{$\mu$} (M);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M21) to
    node[sloped,above]{$\mu$} (M);
  \end{tikzpicture}
  \caption{Commutative diagram for $\mu\circ\left(\mu \times
    \idm{M}\right) = \mu \circ \left(\idm{M} \times \mu\right) \circ
    \alpha$.} 
  \label{fig:monoid_mu_alpha}
\end{figure}
Very often the isomorphism $\alpha$ is omitted i.e. 
\[
M\times\left(M \times M\right)
= \left(M \times M\right)\times M = M^3
\]
and the morphism
equality is written as follow
\[
\mu\circ\left(\mu \times \idm{M}\right) =
\mu \circ \left(\idm{M} \times \mu\right)
\]
The corresponding commutative diagram is shown on
\cref{fig:monoid_mu}.
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=above:$M^3$] (M3) at (0,3) {};    
    \node[ele,label=above:$M \times M$] (M21) at (3,3) {};    
    \node[ele,label=below:$M \times M$] (M22) at (0,0) {};    
    \node[ele,label=below:$M$] (M) at (3,0) {};    

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M3) to
    node[sloped,below]{$\idm{M} \times \mu$} (M21);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M3) to
    node[sloped,above]{$\mu \times \idm{M}$} (M22);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M22) to
    node[sloped,above]{$\mu$} (M);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M21) to
    node[sloped,above]{$\mu$} (M);
  \end{tikzpicture}
  \caption{Commutative diagram for $\mu\circ\left(\mu \times
    \idm{M}\right) = \mu \circ \left(\idm{M} \times \mu\right)$.}
  \label{fig:monoid_mu}
\end{figure}

For \eqref{eq:monoid2} consider a morphism $\eta$ from
a one point set $I = \{0\}$ to a special element $e \in M$ such that
$\forall m \in M: e \cdot m = m \cdot e = m$. I.e. $\eta: I \to M$ and
$e = \eta(0)$. Consider 2 sets $B = I \times M$ and $B' = M \times I$. 
We have 2 \mynameref{def:isomorphism}s: $B \cong_\lambda M$ and $B'
\cong_\rho M$ where the isomorphisms are defined as follow
\[
\lambda(0, m) = m
\] 
and
\[
\rho(m, 0) = m.
\] 

If we apply \mynameref{def:product_of_morphisms} $\eta \times \mu$ and
$\mu \times \eta$ on $B$ and $B'$ respectively then we get
\begin{eqnarray}
\eta \times \idm{M} \left(0 \times m\right) = e \times m,
\nonumber \\
\idm{M} \times \eta \left(m \times 0\right) = m \times e.
\nonumber
\end{eqnarray}
If we apply $\mu$ on the result then we get
\begin{eqnarray}
\mu \left(\eta \times \idm{M} \left(0 \times m\right) \right) = e \cdot m,
\nonumber \\
\idm{M} \times \eta \left(m \times 0\right) = m \times e.
\nonumber
\end{eqnarray}
\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts
    
    \node[ele,label=above:$M$] (M') at (0,3) {};    
    \node[ele,label=above:$M \times M$] (M21) at (3,3) {};    
    \node[ele,label=below:$M \times M$] (M22) at (0,0) {};    
    \node[ele,label=below:$M$] (M) at (3,0) {};    

    \draw [double equal sign distance] (M') to (M);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M') to
    node[sloped,below]{$\lambda$} (M21);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M') to
    node[sloped,above]{$\rho$} (M22);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M22) to
    node[sloped,above]{$\mu$} (M);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (M21) to
    node[sloped,above]{$\mu$} (M);
  \end{tikzpicture}
  \caption{Commutative diagram for $\mu \circ (\eta \times \idm{M})
    \circ \lambda = \mu \circ (\idm{M} \times \mu) \circ \rho =
    \idm{M}$ .} 
  \label{fig:monoid_eta_lambda_rho}
\end{figure}
The \eqref{eq:monoid2} leads to the following equation for morphisms
\[
\mu \circ (\eta \times \idm{M}) \circ \lambda = 
\mu \circ (\idm{M} \times \mu) \circ \rho = 
\idm{M}
\]
or the commutative diagram show on \cref{fig:monoid_eta_lambda_rho}.



%% The monoid definition (\cref{def:monoid}) is not quite that we need
%% because it uses internal structure of the monoid for the description
%% i.e. it works in the terms of Set theory but not Category one. We will
%% use another definition from \cite{bib:maclane71}. 
%% \begin{definition}[Monoidal object]
%% \label{def:monoidal_object}
%% Consider a category $\cat{C}$ and an object $t$ that belongs to the
%% category. 
%% \end{definition}


\subsection{Programming languages}
In our toy example \cref{fig:pl_example} the type String is
\mynameref{def:initial_object} and type Bool is the
\mynameref{def:terminal_object}. From other side there are types in
different programming languages that satisfies the definitions of
initial and terminal objects.

\subsubsection{\textbf{Hask} category}
\begin{example}[Initial object][\textbf{Hask}]
If we avoid lazy evaluations in Haskell (see
\mynameref{rem:hask_lazy_eval}) then we can found several types
as candidates for initial and terminal object in Haskell. 
\label{ex:hask_initial_object}
\mynameref{def:initial_object} in \mynameref{def:haskcategory} is a
type without values 
\begin{minted}{haskell}
data Void
\end{minted}
i.e. you cannot construct a object of the type.

There is only one function from the initial object:
\begin{minted}{haskell}
absurd :: Void -> a
\end{minted}
The function is called absurd because it does absurd action. Nobody
can proof that it does not exist. For the existence proof the
following absurd argument can be used: ``Just provide me an object type
\mintinline{haskell}{Void} and I will provide you the result of
evaluation''.  

There is no function in opposite direction because it would had been
used for the \mintinline{haskell}{Void} object creation. 
\end{example}

\begin{example}[Terminal object][\textbf{Hask}]
\label{ex:hask_terminal_object}
Terminal object (unit) in \mynameref{def:haskcategory} keeps only one element
\begin{minted}{haskell}
data () = ()
\end{minted}
i.e. you can create only one element of the type. You can use the
following function for the creation:
\begin{minted}{haskell}
unit :: a -> ()
unit _ = ()
\end{minted}
\end{example}

\begin{example}[Product][\textbf{Hask}]
\label{ex:hask_product}
The \mynameref{def:product} in \mynameref{def:haskcategory} keeps a
pair and the constructor defined as follows
\begin{minted}{haskell}
(,) :: a -> b -> (a, b)
(,) x y = (x, y)
\end{minted}
There are 2 projectors: 
\begin{minted}{haskell}
fst :: (a, b) -> a
fst (x, _) = x
snd :: (a, b) -> b
snd (_, y) = y
\end{minted}
\end{example}

\begin{example}[Sum][\textbf{Hask}]
\label{ex:hask_sum}
The \mynameref{def:sum} in \mynameref{def:haskcategory} defined as
follows 
\begin{minted}{haskell}
data Either a b = Left a | Right b
\end{minted}

The typical usage is via pattern matching for instance 
\begin{minted}{haskell}
factor :: (a -> c) -> (b -> c) -> Either a b -> c
factor f _ (Left x) = f x
factor _ g (Right y) = g y
\end{minted}
\end{example}


\subsubsection{\textbf{C++} category}
\begin{example}[Initial object][\textbf{C++}]
\label{ex:cpp_initial_object}
In C++ exists a special type that does not hold any values and as
result cannot be created: \mintinline{c++}{void}.
You cannot create an object of that type i.e. you will get a compiler
error if you try.
\end{example}

\begin{example}[Terminal object][\textbf{C++}]
\label{ex:cpp_terminal_object}
C++ 17 introduced a special type that keeps only one value -
\mintinline{c++}{std::monostate}:  
\begin{minted}{c++}
namespace std {
  struct monostate {};
}
\end{minted}
\end{example}

\begin{example}[Product][\textbf{C++}]
\label{ex:cpp_product}
The \mynameref{def:product} in \mynameref{def:cppcategory} keeps a
pair and the constructor defined as follows
\begin{minted}{c++}
namespace std {
  template< class A, class B > struct pair {
    A first;
    B second;
  };
}
\end{minted}

There is a simple usage example
\begin{minted}{c++}
  std::pair<int, bool> p(0, false);

  std::cout << "First projector: " << p.first << std::endl;
  std::cout << "Second projector: " << p.second << std::endl;

\end{minted}
Really any \mintinline{c++}{struct} or \mintinline{c++}{class} can be
considered as a product. 
\end{example}

\begin{example}[Sum][\textbf{C++}]
  \label{ex:cpp_sum}
  If we consider \mynameref{def:object}s as types then
  \mynameref{def:sum} is an object that can be either one or another
  type. The corresponding C/C++ construction that provides an ability
  to keep one of two types is \mintinline{c++}{union}. 

  %% There is an \mintinline{haskell}{Either} implementation from
  %% \mynameref{ex:hask_sum} 
  %% \begin{minted}{c++}
  %%   template <typename A, typename B> class Either
  %%   {
  %%   public:
  %%     Either(const Either& e) : is_left_(e.is_left_){
  %%       if (is_left_){
  %%         data.l = e.data.l;      
  %%       } else {
  %%         data.r = e.data.r;      
  %%       }    
  %%     }
  %%     ~Either(){
  %%       if (is_left_){
  %%         data.l.~A();      
  %%       } else {
  %%         data.r.~B();      
  %%       }        
  %%     }      
  %%     Either(const A& l) : data(l), is_left_(true){
  %%     }
  %%     Either(const B& r) : data(r), is_left_(false){
  %%     }
  %%     const A& left() const {
  %%       if (!is_left_){
  %%         throw std::logic_error("no left");      
  %%       }    
  %%       return data.l;    
  %%     }
  %%     const B& right() const {
  %%       if (is_left_){
  %%         throw std::logic_error("no right");      
  %%       }    
  %%       return data.r;    
  %%     }
  %%   private:
  %%     union Data {
  %%       Data() {}
  %%       Data( const A& a) : l(a) {}
  %%       Data (const B& b) : r(b) {}
  %%       ~Data() {}
  %%       A l;
  %%       B r;
  %%     } data;       
  %%     bool is_left_;  
  %%   };
  %% \end{minted}
  %% The usage example:
  %% \begin{minted}{c++}
  %%   template <typename A, typename B, typename C, typename D>
  %%   auto factor(A f, B g, const Either<C, D>& either) {
  %%     try {
  %%       return f(either.left());               
  %%     }
  %%     catch(...) {
  %%       return g(either.right());                              
  %%     }
  %%   };
    
  %%   auto stringLength = [](std::string s) {
  %%     return static_cast<int>(s.size()); };
  %%   auto id = [](auto x) { return x; };
          
  %%   Either<std::string, int> str = std::string("abc");
  %%   std::cout << "String length:" <<
  %%   factor<>(stringLength, id, str) << std::endl;
  %%   Either<std::string, int> i = 4;
  %%   std::cout << "id(int):" <<
  %%   factor<>(stringLength, id, i) << std::endl;
  %% \end{minted}

  C++17 suggests \mintinline{c++}{std:variant} as a safe replacement
  for \mintinline{c++}{union}. The example of the \mintinline{c++}{factor}
  function is below
  \begin{minted}{c++}
    template <typename A, typename B, typename C, typename D>
    auto factor(A f, B g, const std::variant<C, D>& either) {
      try {
        return f(std::get<C>(either));               
      }
      catch(...) {
        return g(std::get<D>(either));                              
      }
    };
  \end{minted}
  The simple usage as follows:
  \begin{minted}{c++}
    std::variant<std::string, int> var = std::string("abc");
    std::cout << "String length:" <<
    factor<>(stringLength, id, var) << std::endl;
    var = 4;
    std::cout << "id(int):" <<
    factor<>(stringLength, id, var) << std::endl;    
  \end{minted}

\end{example}
TBD
\subsubsection{\textbf{Scala} category}
\begin{example}[Initial object][\textbf{Scala}]
\label{ex:scala_initial_object}
We used a same trick as for \mynameref{ex:hask_initial_object} in
\mynameref{def:haskcategory} and define
\mynameref{def:initial_object} in \mynameref{def:scalacategory} as a
type without values 
\begin{minted}{scala}
sealed trait Void
\end{minted}
i.e. you cannot construct a object of the type.
\end{example}

\begin{example}[Terminal object][\textbf{Scala}]
\label{ex:scala_terminal_object}
We used a same trick as for \mynameref{ex:hask_terminal_object}
in \mynameref{def:haskcategory} and define
\mynameref{def:terminal_object} in \mynameref{def:scalacategory} as a
type with only one value
\begin{minted}{scala}
abstract final class Unit extends AnyVal
\end{minted}
TBD
i.e. you can create only one element of the type.
\end{example}

TBD

\subsection{Quantum mechanics}
\begin{example}[Initial object][\textbf{FdHilb}]
\label{ex:quant_initial_object}
We will use a Hilber space of dimensional 0 as the
\mynameref{def:initial_object}. I.e. the set that does not have any
states in it.
\end{example}

\begin{example}[Terminal object][\textbf{FdHilb}]
  \label{ex:quant_terminal_object}
We will use a Hilber space of dimensional 1 as the
\mynameref{def:terminal_object}. I.e. the set of complex numbers
$\mathbb{C}$.   
\end{example}

\begin{example}[Product][\textbf{FdHilb}]
  \label{ex:quant_product}
  The \mynameref{def:product} in \mynameref{def:fdhilbcategory} is a
  \mynameref{def:fdhilb_direct_sum}.
\end{example}

\begin{example}[Sum][\textbf{FdHilb}]
  \label{ex:quant_sum}
  The \mynameref{def:sum} in \mynameref{def:fdhilbcategory} is a
  \mynameref{def:fdhilb_direct_sum}.
\end{example}

TBD

