%% -*- coding:utf-8 -*-
\chapter{Functors}

\section{Definitions}

\begin{definition}[Functor]
\label{def:functor}
Let $\cat{C}$ and $\cat{D}$ are 2 categories. A mapping $F: \cat{C}
\to \cat{D}$ between the categories is called \textit{functor} is it
preserves the internal structure (see \cref{fig:functor}): 
\begin{itemize}
\item $\forall a_C \in \catob{C}, \exists a_D \in \catob{D}$ such that
  $a_D = F( a_C )$
\item $\forall f_C \in \cathom{C}, \exists f_D \in \cathom{D}$ such
  that $\dom f_D = F (\dom f_C), \cod f_D = F (\cod f_C)$. We will use
  the following notation later: $f_D = F(f_C)$.
\item $\forall f_C, g_C$ the following equation holds: 
\[
F\left(f_C \circ
  f_D\right) = F\left(f_C\right) \circ F\left(g_C\right) = f_D \circ
  g_D.
\]
\item $\forall x \in \catob{C}: F(\idarrow{x}) = \idarrow{F(x)}$.
\end{itemize}  

\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts

    \node at (0,3) {$C$};        
    \node at (4,3) {$D$};        

    \node[ele,label=above:$a_C$] (ac) at (0,2) {};    
    \node[ele,label=below:$b_C$] (bc) at (0,0) {};    
    \node[ele,label=above:$a_D$] (ad) at (4,2) {};
    \node[ele,label=below:$b_D$] (bd) at (4,0) {};

    \node[draw,fit= (ac) (bc),minimum width=2cm, minimum
      height=3.5cm] {} ;
    \node[draw,fit= (ad) (bd),minimum width=2cm, minimum
      height=3.5cm] {} ;

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (ac) to
    node[left]{$f_C$} (bc);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (ad) to
    node[right]{$f_D$} (bd);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (ac) to
    node[sloped,above]{$a_D = F(a_C)$} (ad);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (bc) to
    node[sloped,above]{$b_D = F(b_C)$} (bd);
  \end{tikzpicture}
  \caption{Functor $F: \cat{C} \to \cat{D}$ definition}
  \label{fig:functor}
\end{figure}
\end{definition}

\begin{remark}[Functor]
When we say that functor preserve internal structure means that
functor is not just mapping between \mynameref{def:object}s but also
between \mynameref{def:morphism}s.  
\end{remark}

Thus functor is something that allows map one category into another.
The initial category can be considered as a pattern thus the mapping
is some kind of searching of the pattern inside another category.

\begin{definition}[Endofunctor]
\label{def:endofunctor}
Let $\cat{C}$ is a \mynameref{def:category}. The
\mynameref{def:functor} $E: \cat{C} \to \cat{C}$ i.e. 
the functor from a category to the same category is called
\textit{endofunctor}. 
\end{definition}

\begin{definition}[Identity functor]
\label{def:idfunctor}
Let $\cat{C}$ is a \mynameref{def:category}. The
\mynameref{def:functor} $Id_C: \cat{C} \to \cat{C}$ is called \textit{identity
functor} if for every object $a \in \catob{C}$
\[
Id_c(a) = a
\]
and for every \mynameref{def:morphism} $f \in \cathom{C}$
\[
Id_c(f) = f
\] 
\end{definition}

\begin{remark}[Identity functor]
  \label{rem:idfunctor}
  First of all notice that \mynameref{def:idfunctor} is an
  \mynameref{def:endofunctor}.

  There is difference between identity functor and \mynameref{def:id}
  because the first one has deal with both \mynameref{def:object}s and
  \mynameref{def:morphism}s while the second one with the objects
  only. 
\end{remark}

\begin{definition}[Category Composition]
TBD
\end{definition}

\begin{definition}[Category Identity]
TBD
\end{definition}

\begin{definition}[\textbf{Cat} category]
TBD
\end{definition}

As an extension of Cartesian product is used so called Category product
\begin{definition}[Category Product]
\label{def:category_product}
If we have 2 categories $\cat{C}$ and $\cat{D}$ then we can construct
a new category $\cat{C} \times \cat{D}$ with the following components:
\begin{itemize}
\item \mynameref{def:object}s are the pairs $(c,d)$ where $c \in
  \catob{C}$ and $d \in \catob{D}$
\item \mynameref{def:morphism}s are the pair $(f,g)$ where $f \in
  \cathom{C}$ and $g \in \cathom{D}$
\item \mynameref{axm:composition} is defined as follows 
\(
(f_1, g_1) \circ (f_2, g_2) = (f_1 \circ f_2, g_1 \circ g_2)
\)
\item Identity is defined as follows: $\idarrow{C \times D} = 
\left(\idarrow{C}, \idarrow{D}\right)$
\end{itemize}
\end{definition}

\begin{definition}[Bifunctor]
\label{def:bifunctor}
Bifunctor is a \mynameref{def:functor} whose \mynameref{def:domain} is
a \mynameref{def:category_product}. 
\end{definition}

\begin{definition}[Terminal object in \textbf{Cat} category]
\label{def:terminal_object_cat}
\index{Terminal object!\textbf{Cat} category}
Let consider $\Delta_c$ is a trivial functor from \mynameref{def:category}
$\cat{A}$ to category $\cat{C}$ such that $\forall a \in \catob{A}:
\Delta_c a = c$ -fixed object in $\cat{C}$ and 
$\forall f \in \cathom{A}: \Delta_c f = \idarrow{c}$.
\end{definition}

\begin{definition}[Contravariant functor]
\label{def:contravariant_functor}
If we have a categories $\cat{C}$ and $\cat{D}$ then the
\mynameref{def:functor} $\cat{C^{op}} \to \cat{D}$ is called
\textit{contravariant functor}. 
\end{definition}

\begin{definition}[Profunctor]
\label{def:profunctor}
If we have a category $\cat{C}$ then the \mynameref{def:bifunctor}
$\cat{C^{op}} \times \cat{C} \to \cat{C}$ is called
\textit{profunctor}. 
\end{definition}

\section{Curry-Howard-Lambek correspondence}
There is an interesting correspondence between computer programs and
mathematical proofs.

TBD

\section{Monoidal category}
\begin{definition}[Monoid]
  \label{def:monoid}
  The set of elements $M$ with defined binary operation $\circ$ we will call
  as a monoid if the following conditions are satisfied.
  \begin{enumerate}
  \item Closure: $\forall a, b \in M$: $a \circ b \in M$
  \item Associativity: $\forall a, b, c \in M$:
    $a \circ \left( b \circ c \right) =
    \left( a \circ b \right) \circ c$
  \item Identity element: $\exists e \in M$ such that
    $\forall a \in M$: $e \circ a = a \circ e = a$
  \end{enumerate}
\end{definition}
TBD


\section{Examples}

\subsection{\textbf{Set} category}
TBD

\subsection{Programming languages}

\subsubsection{\textbf{Hask} category}
TBD

\begin{example}[Terminal object in \textbf{Cat} category][\textbf{Hask}]
\label{ex:terminal_object_cat_hask}
\begin{minted}{haskell}
data Const c a = Const c
fmap :: (a -> b) -> Const c a -> Const c b
fmap f (Const c a) = Const c
\end{minted}
\end{example}

\begin{example}[Maybe as a functor][\textbf{Hask}]
\label{ex:maybe_functor}
Lets show how the \mintinline{haskell}{Maybe a} type can be
constructed from different 
\mynameref{def:functor}s and as result show that the
\mintinline{haskell}{Maybe a} is also 
\mynameref{def:functor}. 
\begin{minted}{haskell}
data Maybe a = Nothing | Just a
-- This is equivalent to
data Maybe a = Either () (Identity a)
-- Either is a bifunctor and () == Const () a 
-- Thus Maybe is a composition of 2 functors 
\end{minted}
\end{example}

\begin{example}[Contravariant functor][\textbf{Hask}]
\label{ex:contravariant_functor_hask}
TBD
\begin{minted}{haskell}
class Contravariant f where
      contramap :: (a -> b) -> f b -> f a
\end{minted}
\end{example}

\begin{example}[Profunctor][\textbf{Hask}]
\label{ex:contravariant_functor_hask}
TBD
\begin{minted}{haskell}
class Profunctor p where
      dimap :: (a' -> a) -> ( b -> b' ) -> p a b -> p a' b'
      -- p a b == a -> b
      dimap f g h = g . h . f
\end{minted}
\end{example}


\subsubsection{\textbf{C++} category}
TBD

\subsubsection{\textbf{Scala} category}
TBD

\subsection{Quantum mechanics}

TBD
