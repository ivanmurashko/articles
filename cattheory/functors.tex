%% -*- coding:utf-8 -*-
\chapter{Functors}

\section{Definitions}

\begin{definition}[Functor]
\label{def:functor}
Let $\cat{C}$ and $\cat{D}$ are 2 categories. A mapping $F: \cat{C}
\to \cat{D}$ between the categories is called \textit{functor} is it
preserves the internal structure (see \cref{fig:functor}): 
\begin{itemize}
\item $\forall a_C \in \catob{C}, \exists a_D \in \catob{D}$ such that
  $a_d = F( a_C )$
\item $\forall f_C \in \cathom{C}, \exists f_D \in \cathom{D}$ such
  that $\dom f_D = F (\dom f_C), \cod f_D = F (\cod f_C)$. We will use
  the following notation later: $f_D = F(f_C)$.
\item $\forall f_C, g_C$ the following equation holds: 
\[
F\left(f_C \circ
  f_D\right) = F\left(f_C\right) \circ F\left(g_C\right) = f_D \circ
  g_D.
\]
\item $\forall x \in \catob{C}: F(\idarrow{x}) = \idarrow{F(x)}$.
\end{itemize}  

\begin{figure}
  \centering
  \begin{tikzpicture}[ele/.style={fill=black,circle,minimum
        width=.8pt,inner sep=1pt},every fit/.style={ellipse,draw,inner
        sep=-2pt}]

    % the texts

    \node at (0,3) {$C$};        
    \node at (4,3) {$D$};        

    \node[ele,label=above:$a_C$] (ac) at (0,2) {};    
    \node[ele,label=below:$b_C$] (bc) at (0,0) {};    
    \node[ele,label=above:$a_D$] (ad) at (4,2) {};
    \node[ele,label=below:$b_D$] (bd) at (4,0) {};

    \node[draw,fit= (ac) (bc),minimum width=2cm, minimum
      height=3.5cm] {} ;
    \node[draw,fit= (ad) (bd),minimum width=2cm, minimum
      height=3.5cm] {} ;

    \draw[->,thick,shorten <=2pt,shorten >=2pt] (ac) to
    node[left]{$f_C$} (bc);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (ad) to
    node[right]{$f_D$} (bd);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (ac) to
    node[sloped,above]{$a_D = F(a_C)$} (ad);
    \draw[->,thick,shorten <=2pt,shorten >=2pt] (bc) to
    node[sloped,above]{$b_D = F(b_C)$} (bd);
  \end{tikzpicture}
  \caption{Functor $F: \cat{C} \to \cat{D}$ definition}
  \label{fig:functor}
\end{figure}
\end{definition}

\begin{remark}[Functor]
When we say that functor preserve internal structure means that
functor is not just mapping between \mynameref{def:object}s but also
between \mynameref{def:morphism}s.  
\end{remark}

\begin{definition}[Category Composition]
TBD
\end{definition}

\begin{definition}[Category Identity]
TBD
\end{definition}

\begin{definition}[\textbf{Cat} category]
TBD
\end{definition}

\begin{definition}[Category Product]
TBD
\end{definition}

\begin{definition}[Bifunctor]
\label{def:bifunctor}
TBD
\end{definition}

\begin{definition}[Terminal object in \textbf{Cat} category]
\label{def:terminal_object_cat}
\index{Terminal object!\textbf{Cat} category}
Let consider $\Delta_c$ is a trivial functor from \mynameref{def:category}
$\cat{A}$ to category $\cat{C}$ such that $\forall a \in \catob{A}:
\Delta_c a = c$ -fixed object in $\cat{C}$ and 
$\forall f \in \cathom{A}: \Delta_c f = \idarrow{c}$.
\end{definition}

\begin{definition}[Contravariant functor]
\label{def:contravariant_functor}
If we have a categories $\cat{C}$ and $\cat{D}$ then the
\mynameref{def:functor} $\cat{C^{op}} \to \cat{D}$ is called
\textit{contravariant functor}. 
\end{definition}

\begin{definition}[Profunctor]
\label{def:profunctor}
If we have a category $\cat{C}$ then the \mynameref{def:bifunctor}
$\cat{C^{op}} \times \cat{C} \to \cat{C}$ is called
\textit{profunctor}. 
\end{definition}

\section{Natural transformations}

TBD

\section{Monoidal category}
\begin{definition}[Monoid]
  \label{def:monoid}
  The set of elements $M$ with defined binary operation $\circ$ we will call
  as a monoid if the following conditions are satisfied.
  \begin{enumerate}
  \item Closure: $\forall a, b \in M$: $a \circ b \in M$
  \item Associativity: $\forall a, b, c \in M$:
    $a \circ \left( b \circ c \right) =
    \left( a \circ b \right) \circ c$
  \item Identity element: $\exists e \in M$ such that
    $\forall a \in M$: $e \circ a = a \circ e = a$
  \end{enumerate}
\end{definition}
TBD


\section{Examples}

\subsection{\textbf{Set} category}
TBD

\subsection{Programming languages}

\subsubsection{\textbf{Hask} category}
TBD

\begin{example}[Terminal object in \textbf{Cat} category][\textbf{Hask}]
\label{ex:terminal_object_cat_hask}
\begin{minted}{haskell}
data Const c a = Const c
fmap :: (a -> b) -> Const c a -> Const c b
fmap f (Const c a) = Const c
\end{minted}
\end{example}

\begin{example}[Maybe as a functor][\textbf{Hask}]
\label{ex:maybe_functor}
Lets show how the \mintinline{haskell}{Maybe a} type can be
constructed from different 
\mynameref{def:functor}s and as result show that the
\mintinline{haskell}{Maybe a} is also 
\mynameref{def:functor}. 
\begin{minted}{haskell}
data Maybe a = Nothing | Just a
-- This is equivalent to
data Maybe a = Either () (Identity a)
-- Either is a bifunctor and () == Const () a 
-- Thus Maybe is a composition of 2 functors 
\end{minted}
\end{example}

\begin{example}[Contravariant functor][\textbf{Hask}]
\label{ex:contravariant_functor_hask}
TBD
\begin{minted}{haskell}
class Contravariant f where
      contramap :: (a -> b) -> f b -> f a
\end{minted}
\end{example}

\begin{example}[Profunctor][\textbf{Hask}]
\label{ex:contravariant_functor_hask}
TBD
\begin{minted}{haskell}
class Profunctor p where
      dimap :: (a' -> a) -> ( b -> b' ) -> p a b -> p a' b'
      -- p a b == a -> b
      dimap f g h = g . h . f
\end{minted}
\end{example}


\subsubsection{\textbf{C++} category}
TBD

\subsubsection{\textbf{Scala} category}
TBD

\subsection{Quantum mechanics}

TBD
