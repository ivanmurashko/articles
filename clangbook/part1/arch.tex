%% -*- coding:utf-8 -*-
\chapter{Architecture}
You can find some information about the clangâ€™s internal architecture and its
relationship with other LLVM components. We will start with the clang driver -
the backbone for the compiler as soon as it runs all compilation phases and
controls their execution. Next, we will focus on the first part of the frontend
that includes lexical and semantic analysis and produces AST (abstract syntax
tree) as the primary output. The AST is the foundation for most clang tools, and
we will look at it more deeply. 

\section{Clang driver overview}

When we spoke about \clang we should separate 2 things:
\begin{itemize}
\item driver
\item compiler frontend 
\end{itemize}
Both of them are called \clang but perform different
operations. The driver does the following:
\begin{itemize}
  \item it invokes and controls different stages of compilation process (see
    fig. \ref{fig:clang_driver})
  \item it also produces the final result of the compilation (executable,
      object file, etc.)
  \item the driver is responsible for check environment and setup correct
      compilation flags, for instance be sure that
      \mintinline{text}{/usr/include} is in the search paths for Linux OS.    
\end{itemize}

\begin{figure}
\begin{center}
\smartdiagramset{border color=none,
back arrow disabled=true}
\smartdiagram[flow diagram:horizontal]{Frontend,Middle-end, Backend,Assembler,Linker} 
\end{center}
  \caption{Clang driver}
  \label{fig:clang_driver}
\end{figure}
The stages of compilation are standard for ordinary compiler and nothing special
is here:
\begin{itemize}
\item Frontend: it does lexical analysis and parsing.
\item Middle-end: it does different optimization on the intermediate
  representation (LLVM-IR) code
\item Backend: Native code generation
\item Assembler: Running assembler
\item Linker: Running linker
\end{itemize}
Thus the driver gets source file and compilation flags and produces build
artefact (executable, object file, etc.)

We will use the test file \mintinline{text}{main.cpp} for our experiments. The
file implements a trivial C++ program
\inputminted{c++}{./src/simple/main.cpp}

The driver for that file is invoked by the following command
\begin{minted}{text}
clang main.cpp -o main -lstdc++
\end{minted}
The result of the invocation is an executable \mintinline{text}{main}. 

You can get the phases using the following command
\begin{minted}{text}
  clang -ccc-print-phases main.cpp
\end{minted}

Output
\begin{minted}{text}
+- 0: input, "main.cpp", c++
+- 1: preprocessor, {0}, c++-cpp-output
+- 2: compiler, {1}, ir
+- 3: backend, {2}, assembler
+- 4: assembler, {3}, object
5: linker, {4}, image
\end{minted}

The driver also adds a lot of additional arguments, for instance
search paths for system includes that could be platform specific.
You can use \mintinline{text}{-###} clang option to print actual
command line used by the driver
\begin{minted}[breaklines]{text}
$clang -### main.cpp -o main -lstdc++
clang version 12.0.1 (Fedora 12.0.1-1.fc34)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/bin
 "/usr/bin/clang-12" "-cc1" "-triple" "x86_64-unknown-linux-gnu" "-emit-obj" "-mrelax-all" ...
\end{minted}

\section{Clang frontend overview}
One may see that the clang compiler toolchain corresponds the pattern
wildly described at different compiler books
\cite{book:engineering_a_compiler}. Despite the fact, the frontend
part is quite different from a typical compiler frontend described at
the books. The primary reason for this is C++ language and it's
complexity. Some features (macros) can change the source code itself
another (typedef) can effect on token kind. As result the relations
between different frontend components can be represented as it's shown
on fig \ref{fig:clang_frontend}
\begin{figure}
\begin{center}
\smartdiagramset{border color=none,
back arrow disabled=true}
\smartdiagram[flow diagram:horizontal]{Preprocessor/Lexer,Parser,Codegen}
\end{center}
  \caption{Clang frontend components}
  \label{fig:clang_frontend}
\end{figure}

You can bypass the driver call and run the clang frontend  with
\mintinline{text}{-cc1} option. 

The first part is the \textbf{Lexer}. It's primary goal is to convert the input
program into a stream of tokens. The token stream can be printed with
\mintinline{text}{-dump-tokens} options as follows
\begin{minted}[breaklines]{text}
  $ clang -cc1 -dump-tokens src/simple/main.cpp
\end{minted}
The output of the command is below
\begin{minted}[breaklines]{text}
int 'int'        [StartOfLine]  Loc=<src/simple/main.cpp:1:1>
identifier 'main'        [LeadingSpace] Loc=<src/simple/main.cpp:1:5>
l_paren '('             Loc=<src/simple/main.cpp:1:9>
r_paren ')'             Loc=<src/simple/main.cpp:1:10>
l_brace '{'      [LeadingSpace] Loc=<src/simple/main.cpp:1:12>
return 'return'  [StartOfLine] [LeadingSpace]   Loc=<src/simple/main.cpp:2:3>
numeric_constant '0'     [LeadingSpace] Loc=<src/simple/main.cpp:2:10>
semi ';'                Loc=<src/simple/main.cpp:2:11>
r_brace '}'      [StartOfLine]  Loc=<src/simple/main.cpp:3:1>
eof ''          Loc=<src/simple/main.cpp:3:2>
\end{minted}

Another part is the \textbf{Parser}. It produces \myindex{AST} that
can be shown with the following command
\begin{minted}[breaklines]{text}
  $ clang -cc1 -ast-dump src/simple/main.cpp
  \end{minted}
The output of the command is below
\begin{minted}[breaklines]{text}
TranslationUnitDecl 0x5581925de3b8 <<invalid sloc>> <invalid sloc>
|-TypedefDecl 0x5581925dec20 <<invalid sloc>> <invalid sloc> implicit __int128_t '__int128'
| `-BuiltinType 0x5581925de980 '__int128'
|-TypedefDecl 0x5581925dec90 <<invalid sloc>> <invalid sloc> implicit __uint128_t 'unsigned __int128'
| `-BuiltinType 0x5581925de9a0 'unsigned __int128'
|-TypedefDecl 0x5581925df008 <<invalid sloc>> <invalid sloc> implicit __NSConstantString '__NSConstantString_tag'
| `-RecordType 0x5581925ded80 '__NSConstantString_tag'
|   `-CXXRecord 0x5581925dece8 '__NSConstantString_tag'
|-TypedefDecl 0x5581925df0a0 <<invalid sloc>> <invalid sloc> implicit __builtin_ms_va_list 'char *'
| `-PointerType 0x5581925df060 'char *'
|   `-BuiltinType 0x5581925de460 'char'
|-TypedefDecl 0x5581926237d8 <<invalid sloc>> <invalid sloc> implicit __builtin_va_list '__va_list_tag[1]'
| `-ConstantArrayType 0x558192623780 '__va_list_tag[1]' 1
|   `-RecordType 0x5581925df190 '__va_list_tag'
|     `-CXXRecord 0x5581925df0f8 '__va_list_tag'
`-FunctionDecl 0x558192623880 <src/simple/main.cpp:1:1, line:3:1> line:1:5 main 'int ()'
  `-CompoundStmt 0x5581926239c0 <col:12, line:3:1>
    `-ReturnStmt 0x5581926239b0 <line:2:3, col:10>
      `-IntegerLiteral 0x558192623990 <col:10> 'int' 0
\end{minted}

\section{Clang AST}
The \myindex{AST} is the skeleton for clang frontend. It's also the primary
instrument for linters and other clang tools. The AST keeps result of syntax and
semantic analysis and represent a tree with leafs for different objects, such as
function declaration for loop body etc. The clang provides advanced tools for
search (match) different nodes. The tools are implemented in the form of DSL
(domain specific language). There is important to understand how its
implemented to be able using it.

TBD
