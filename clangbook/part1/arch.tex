%% -*- coding:utf-8 -*-
\chapter{Architecture}

You can find some info about clang internal architecture and relation with other
LLVM components. We will start with clang driver - the backbone for the
compiler as soon as it runs all compilation phases and controls their
execution. We will focus on the first part of compilation - frontend that
includes lexical and semantic analysis and produces AST (abstract syntax tree)
as the primary output. The AST is the foundation for majority of clang tools and
we will look at it more deeply. 

\section{Clang driver overview}

When we spoke about \textbf{clang} we should separate 2 things:
\begin{itemize}
\item driver
\item compiler frontend 
\end{itemize}
Both of them are called \textbf{clang} but perform different
operations. The driver invokes different stages of compilation process
(see fig. \ref{fig:clang_driver}). 
\begin{figure}
\begin{center}
\smartdiagramset{border color=none,
back arrow disabled=true}
\smartdiagram[flow diagram:horizontal]{Frontend,Middle-end, Backend,Assembler,Linker} 
\end{center}
  \caption{Clang driver}
  \label{fig:clang_driver}
\end{figure}
The stages are standard for ordinary compiler and nothing special is
there:
\begin{itemize}
\item Frontend: it does lexical analysis and parsing.
\item Middle-end: it does different optimization on the intermediate
  representation (LLVM-IR) code
\item Backend: Native code generation
\item Assembler: Running assembler
\item Linker: Running linker
\end{itemize}

The driver is invoked by the following command
\begin{minted}{text}
clang main.cpp -o main -lstdc++
\end{minted}
The driver also adds a lot of additional arguments, for instance
search paths for system includes that could be platform specific.
You can use \mintinline{text}{-###} clang option to print actual
command line used by the driver
\begin{minted}[breaklines]{text}
$clang -### main.cpp -o main -lstdc++
clang version 12.0.1 (Fedora 12.0.1-1.fc34)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/bin
 "/usr/bin/clang-12" "-cc1" "-triple" "x86_64-unknown-linux-gnu" "-emit-obj" "-mrelax-all" ...
\end{minted}

\section{Clang frontend overview}
One may see that the clang compiler toolchain corresponds the pattern
wildly described at different compiler books
\cite{book:engineering_a_compiler}. Despite the fact, the frontend
part is quite different from a typical compiler frontend described at
the books. The primary reason for this is C++ language and it's
complexity. Some features (macros) can change the source code itself
another (typedef) can effect on token kind. As result the relations
between different frontend components can be represented as it's shown
on fig \ref{fig:clang_frontend}
\begin{figure}
\begin{center}
\smartdiagramset{border color=none,
back arrow disabled=true}
\smartdiagram[flow diagram:horizontal]{Preprocessor/Lexer,Parser,Codegen}
\end{center}
  \caption{Clang frontend components}
  \label{fig:clang_frontend}
\end{figure}

You can bypass the driver call and run the clang frontend  with
\mintinline{text}{-cc1} option. We are going to use it for our future
experiments with one simple program:
\inputminted{c++}{./src/simple/main.cpp}

The first part is the \textbf{Lexer}. It's primary goal is to convert the input
program into a stream of tokens. The token stream can be printed with
\mintinline{text}{-dump-tokens} options as follows
\begin{minted}[breaklines]{text}
  $ clang -cc1 -dump-tokens src/simple/main.cpp
\end{minted}
The output of the command is below
\begin{minted}[breaklines]{text}
int 'int'        [StartOfLine]  Loc=<src/simple/main.cpp:1:1>
identifier 'main'        [LeadingSpace] Loc=<src/simple/main.cpp:1:5>
l_paren '('             Loc=<src/simple/main.cpp:1:9>
r_paren ')'             Loc=<src/simple/main.cpp:1:10>
l_brace '{'      [LeadingSpace] Loc=<src/simple/main.cpp:1:12>
return 'return'  [StartOfLine] [LeadingSpace]   Loc=<src/simple/main.cpp:2:3>
numeric_constant '0'     [LeadingSpace] Loc=<src/simple/main.cpp:2:10>
semi ';'                Loc=<src/simple/main.cpp:2:11>
r_brace '}'      [StartOfLine]  Loc=<src/simple/main.cpp:3:1>
eof ''          Loc=<src/simple/main.cpp:3:2>
\end{minted}

Another part is the \textbf{Parser}. It produces \myindex{AST} that
can be shown with the following command
\begin{minted}[breaklines]{text}
  $ clang -cc1 -ast-dump src/simple/main.cpp
  \end{minted}
The output of the command is below
\begin{minted}[breaklines]{text}
TranslationUnitDecl 0x5581925de3b8 <<invalid sloc>> <invalid sloc>
|-TypedefDecl 0x5581925dec20 <<invalid sloc>> <invalid sloc> implicit __int128_t '__int128'
| `-BuiltinType 0x5581925de980 '__int128'
|-TypedefDecl 0x5581925dec90 <<invalid sloc>> <invalid sloc> implicit __uint128_t 'unsigned __int128'
| `-BuiltinType 0x5581925de9a0 'unsigned __int128'
|-TypedefDecl 0x5581925df008 <<invalid sloc>> <invalid sloc> implicit __NSConstantString '__NSConstantString_tag'
| `-RecordType 0x5581925ded80 '__NSConstantString_tag'
|   `-CXXRecord 0x5581925dece8 '__NSConstantString_tag'
|-TypedefDecl 0x5581925df0a0 <<invalid sloc>> <invalid sloc> implicit __builtin_ms_va_list 'char *'
| `-PointerType 0x5581925df060 'char *'
|   `-BuiltinType 0x5581925de460 'char'
|-TypedefDecl 0x5581926237d8 <<invalid sloc>> <invalid sloc> implicit __builtin_va_list '__va_list_tag[1]'
| `-ConstantArrayType 0x558192623780 '__va_list_tag[1]' 1
|   `-RecordType 0x5581925df190 '__va_list_tag'
|     `-CXXRecord 0x5581925df0f8 '__va_list_tag'
`-FunctionDecl 0x558192623880 <src/simple/main.cpp:1:1, line:3:1> line:1:5 main 'int ()'
  `-CompoundStmt 0x5581926239c0 <col:12, line:3:1>
    `-ReturnStmt 0x5581926239b0 <line:2:3, col:10>
      `-IntegerLiteral 0x558192623990 <col:10> 'int' 0
\end{minted}

\section{Clang AST}
The \myindex{AST} is the skeleton for clang frontend. It's also the primary
instrument for linters and other clang tools. The AST keeps result of syntax and
semantic analysis and represent a tree with leafs for different objects, such as
function declaration for loop body etc. The clang provides advanced tools for
search (match) different nodes. The tools are implemented in the form of DSL
(domain specific language). There is important to understand how its
implemented to be able using it.

TBD
