%% -*- coding:utf-8 -*-
\chapter{Features}

You can find some info about different clang features at the chapter

\section{Precompiled headers}
Precompiled headers or \textbf{pch} is a clang feature that was
designed with the goal to improve clang frontend performance. The
basic idea was to create AST\index{AST} for a header file and reuse the AST for
some purposes.

\subsection{User guide}
Generate you pch file is simple \cite{clang:user_manual}. Suppose you have a header file with
name \textbf{header.h}:
\inputminted{c++}{./src/pch/simple/header.h} then you can generate a pch for it with
\begin{minted}{text}
clang -x c++-header header.h -o header.pch
\end{minted}
the option \mintinline{text}{-x c++-header} was used there. The option says that
the header file has to be treated as a c++ header file. The output
file is \mintinline{text}{header.pch}.

The precompiled headers generation is not enough and you may want to
start using them. Typical C++ source file that uses the header may
look like
\inputminted{c++}{./src/pch/simple/main.cpp}
As you may see, the header is included as follows
\begin{minted}{c++}
  ...
#include "header.h"
  ...
\end{minted}
By default clang will not use a pch at the case and you have to
specify it explicitly with
\begin{minted}{text}
clang -include-pch header.pch main.cpp -o main -lstdc++
\end{minted}
We can check the command with debugger and it will give us
\begin{minted}[breaklines]{text}
$ lldb ~/local/llvm-project/build/bin/clang -- -cc1 -include-pch header.pch main.cpp -fsyntax-only
...
(lldb) b clang::ASTReader::ReadAST                                             
...
(lldb) r
...
   4231   llvm::SaveAndRestore<SourceLocation>
-> 4232     SetCurImportLocRAII(CurrentImportLoc, ImportLoc);
   4233   llvm::SaveAndRestore<Optional<ModuleKind>> SetCurModuleKindRAII(
   4234       CurrentDeserializingModuleKind, Type);
   4235 
(lldb) p FileName
(llvm::StringRef) $0 = (Data = "header.pch", Length = 10)
\end{minted}
Note that only the first \mintinline{text}{--include-pch} option will be
processed, all others will be ignored. It reflects the fact that there
can be only one precompiled header for a translation unit.

\section{Modules}
Modules can be considered as a next step in evolution of precompiled
headers. They also represent an parsed AST in binary form but form a
DAG (tree) i.e. one module can include more than one another module
\footnote{Compare that with precompiled header where only one
precompiled header can be introduced for each compilation unit}
\subsection{User guide}.

The C++20 standard \cite{book:ieee_cpp_20} introduced 2 concepts
related to modules. The first one is ordinary modules described at
section 10 of \cite{book:ieee_cpp_20}. Another one is so call header
units \index{header unit}  which are mostly described at section 15.5.
The header units can be considered as an intermediate step between
ordinary headers and modules and allow to use
\mintinline{text}{import} directive to import ordinary headers. The
second approach was the main approach for modules implemented in clang
and we will call it as \textbf{implicit modules}. The first one (primary one
described at \cite{book:ieee_cpp_20}) will be call \textbf{explicit
  modules}. We will start with the implicit modules first.

\subsection{Implicit modules}
The key point for implicit clang modules is \mintinline{text}{modulemap}
file. It describes relation between different modules and interface
provided by the modules. The default name for the file is
\mintinline{text}{module.modulemap}. Typical content is the following
\begin{minted}{text}
module header1 {
  header "header1.h"
  export *
}
\end{minted}
The configuration file can be passed as the command line argument for
compiler and will be used to build and load the module. The module
will be used by the preprocessor when it tries to process include or
import directive.  

\subsubsection{Explicit modules}
TBD

\subsection{Modules internals}
Modules are processed inside
\mintinline{c++}{clang::Preprocessor::HandleIncludeDirective}. There
is a \mintinline{c++}{clang::Preprocessor::HandleHeaderIncludeOrImport} method. 

The module is loaded by
\mintinline{c++}{clang::CompilerInstance::loadModuleFile}. The method caalls
 \mintinline{c++}{clang::CompilerInstance::findOrCompileModuleAndReadAST}

% 

\section{Header-Map files}
TBD
