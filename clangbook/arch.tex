%% -*- coding:utf-8 -*-
\chapter{Architecture}

You can find some info about clang internal architecture and relation
with other LLVM components.

\section{Clang and clang driver overview}

When we spoke about \textbf{clang} we should separate 2 things:
\begin{itemize}
\item driver
\item compiler frontend 
\end{itemize}
Both of them are called \textbf{clang} but perform different
operations. The driver invokes different stages of compilation process
(see fig. \ref{fig:clang_driver}). 
\begin{figure}
\begin{center}
\smartdiagramset{border color=none,
back arrow disabled=true}
\smartdiagram[flow diagram:horizontal]{Frontend,Middle-end, Backend,Assembler,Linker}
\end{center}
  \caption{Clang driver}
  \label{fig:clang_driver}
\end{figure}
The stages are standard for ordinary compiler and nothing special is
there:
\begin{itemize}
\item Frontend: it does lexical analysis and parsing.
\item Middle-end: it does different optimization on the intermediate
  representation (LLVM-IR) code
\item Backend: Native code generation
\item Assembler: Running assembler
\item Linker: Running linker
\end{itemize}

The driver is invoked by the following command
\begin{minted}{text}
clang main.cpp -o main -lstdc++
\end{minted}
The driver also adds a lot of additional arguments, for instance
search paths for system includes that could be platform specific.
You can use \mintinline{text}{-###} clang option to print actual
command line used by the driver
\begin{minted}[breaklines]{text}
$clang -### main.cpp -o main -lstdc++
clang version 12.0.1 (Fedora 12.0.1-1.fc34)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/bin
 "/usr/bin/clang-12" "-cc1" "-triple" "x86_64-unknown-linux-gnu" "-emit-obj" "-mrelax-all" ...
\end{minted}


One may see that the clang compiler toolchain corresponds the pattern
wildly described at different compiler books
\cite{book:engineering_a_compiler}. Despite the fact, the frontend
part is quite different from a typical compiler frontend described at
the books. The primary reason for this is C++ language and it's
complexity. Some features (macros) can change the source code itself
another (typedef) can effect on token kind. As result the relations
between different frontend components can be represented as it's shown
on fig \ref{fig:clang_frontend}
\begin{figure}
\begin{center}
\smartdiagramset{border color=none,
back arrow disabled=true}
\smartdiagram[flow diagram:horizontal]{Preprocessor,Parser,Codegen}
\end{center}
  \caption{Clang frontend components}
  \label{fig:clang_frontend}
\end{figure}

