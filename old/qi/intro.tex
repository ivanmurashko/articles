%% -*- coding:utf-8 -*- 
\section{Введение}
Алгоритмы играют большую роль в вычислительной технике. Алгоритм
представляет собой последовательность шагов необходимых для получения
ответа на некоторую задачу. Каждая задача характеризуется некоторым
числом, который определяет ее размер. Сложность алгоритма оценивается
как число 
простейших операций необходимых для решения поставленной
задачи. Очевидно, что в большинстве случаев (но не всегда) это число
растет с размером задачи. 

\begin{example}
\emph{Поиск элемента массива}
\label{exFind}
Задача - найти элемент массива, удовлетворяющий некоторым
условиям. Размером задачи является число элементов массива $N$. 

В общем случае (не структурированный массив данных) поиск ведется
простым перебором. Этот поиск требует число операций (сравнений) которое
растет линейно с размером массива $O\left( N \right)$.

В случае структурированных данных число операций требуемое для поиска
может быть уменьшено. Например в случае отсортированного массива
сложность задачи растет как $O\left(log N\right)$.
\end{example}

Вместе с тем существование алгоритма еще
не гарантирует его практической реализуемости. В частности алгоритмы
требующие экспоненциального числа шагов от размера исходной задачи
считаются практически не реализуемыми не смотря на то, что с
теоретической точки зрения решение существует.

Одним из примеров является задача о факторизации натурального числа,
т. е. задача о разложении его на простые множители (см. пример
\ref{exFactor}).  

\begin{example}
\emph{Факторизация натуральных чисел}
\label{exFactor}
Задача - найти разложение числа на простые множители.
Размером задачи
является разрядность исходного числа. Например для случая разрядности
$r = 4$: $1 \le N = 15 \le 2^r = 2^4 = 16$). Результат может быть
найден легко и быстро: $15 = 3 \cdot 5$. 

С ростом числа разрядов $r$ число операций необходимых для
факторизации в классических алгоритмах растет как
$O\left(2^r\right)$, что для случая $r = 1000 - 2000$ означает практическую
невозможность факторизации таких чисел. 
\end{example}

Квантовые объекты обладают свойствами отличающимися от классических
объектов, соотвественно алгоритмы, построенные на базе квантовых
объектов могут в ряде случаев обладать характеристиками недоступными
для классических алгоритмов. Например квантовый алгоритм Гровера
\cite{Grover96afast} решает задачу о поиске в неструктурированном
массиве данных (см. пример \ref{exFind}) с помощью
$O\left(\sqrt{N}\right)$ операций. Алгоритм Шора \cite{bShor94}
позволяет решить задачу о факторизации числа (см. пример
\ref{exFactor}) используя линейное число операций $O\left(r\right)$. 
